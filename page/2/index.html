<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//unpkg.com/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//unpkg.com/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
<meta property="og:type" content="website">
<meta property="og:title" content="无限求知的Master Spark">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="无限求知的Master Spark">
<meta property="og:description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
<meta property="og:locale">
<meta property="article:author" content="Linkeer365">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<title>无限求知的Master Spark</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">无限求知的Master Spark</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Linkeer365 技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-globe fa-fw"></i>往期博客链接</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Linkeer365</p>
  <div class="site-description" itemprop="description">可能会高产, 可能会暂停, 但长期来看总会更新</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://linkeer365.github.io/" title="https:&#x2F;&#x2F;linkeer365.github.io&#x2F;" rel="noopener" target="_blank">Linkeer365</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://linkeer365.github.io/Linkeer365ColorfulLife" title="http:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365ColorfulLife" rel="noopener" target="_blank">Linkeer365ColorfulLife</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://linkeer365.github.io/Linkeer365ColorfulLife2" title="http:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365ColorfulLife2" rel="noopener" target="_blank">Linkeer365ColorfulLife2</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://linkeer365.github.io/Linkeer365ColorfulLife3" title="http:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365ColorfulLife3" rel="noopener" target="_blank">Linkeer365ColorfulLife3</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://linkeer365.github.io/Linkeer365TinyMoment" title="https:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365TinyMoment" rel="noopener" target="_blank">Linkeer365TinyMoment</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://linkeer365.github.io/Linkeer365TinyMoment2" title="https:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365TinyMoment2" rel="noopener" target="_blank">Linkeer365TinyMoment2</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://linkeer365.github.io/Linkeer365BookReview" title="https:&#x2F;&#x2F;linkeer365.github.io&#x2F;Linkeer365BookReview" rel="noopener" target="_blank">Linkeer365BookReview</a>
        </li>
    </ul>
  </div>

        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/38389/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/38389/" class="post-title-link" itemprop="url">win10配置clang到clion中</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-22 19:48:33" itemprop="dateCreated datePublished" datetime="2019-10-22T19:48:33+08:00">2019-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:04" itemprop="dateModified" datetime="2022-06-03T21:45:04+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>805</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>考虑到主页<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/351744551/answer/865665382">千里冰封</a>的推荐, 我去安装了试试, 以下是简要记录(我的运气还是挺好的, 至少没有看到一些劝退的帖子, 安装过程算是非常顺利的一次了…)</p>
<ol>
<li>根据<a target="_blank" rel="noopener" href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">这里</a>我们知道一共有3件事要做, {安装mingw64和msys2}-{在msys2中安装llvm和clang}-{在clion中配置cmake和toolchain选项}</li>
<li>安装mingw64和msys2不用提了…</li>
<li>在msys2中安装llvm和clang,命令是<code>pacman -S mingw-w64-x86_64-llvm</code>和<code>pacman -S mingw-w64-x86_64-clang</code>(注意有先后)都懂得, 只要一涉及这种命令行下载东西的时候, 就立马先到网上查一下”换源”什么的, 于是搜索”msys2 换源”, 然后在<a target="_blank" rel="noopener" href="https://mirror.tuna.tsinghua.edu.cn/help/msys2/">这里</a>找到了答案, 这就是一种意识, 很多时候应该变成一种条件反射的东西, 哦一旦出现命令行下载东西就立马换源换源…如果不是命令行的话呢, 就请买一个IDM, 你会发现你后半生的下载会非常自在的…</li>
<li>clion中的配置过程, 首先按照<a target="_blank" rel="noopener" href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">原网页</a>上面显示的配置cmake选项的确是OK的, 那个CC={sth1}, CXX={sth2}一看就知道是环境变量里面的键值对, 所以直接将CC和CXX配置到环境变量里头去即可, 但并没有结束, 此处没有考虑到toolchain的情况, 下面是toolchain的配置.</li>
<li>根据<a target="_blank" rel="noopener" href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000394670-How-can-I-configure-LLVM-Clang-6-0-with-CLION-2018-1">这里</a>我们找到这段话<code>You can&#39;t use clang in CLion on Windows without having MinGW or Cygwin installed. You can try the following:</code>, 说明我们还是要把mingw放在Environment下, 只是make的工具全部换成clang系列的即可 (还有就是能让clion自己detect就不必手动加入绝对路径了…), 这里不多废话, 一图胜千言</li>
<li>第5步图</li>
</ol>
<ul>
<li><img src="/38389/clion_clang%E9%85%8D%E7%BD%AE_toolchain_mingw%E9%83%A8%E5%88%86.jpg" class title="clion_clang配置_toolchain_mingw部分"></li>
<li><img src="/38389/clion_clang%E9%85%8D%E7%BD%AE_toolchain_clang%E9%83%A8%E5%88%86.jpg" class title="clion_clang配置_toolchain_mingw部分"></li>
</ul>
<ol start="7">
<li>成果是这样的</li>
</ol>
<ul>
<li><img src="/38389/clang%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.jpg" class title="clang报错信息"></li>
<li>下次试着把cl.exe也安装上去, 看看每家编译器的水准如何hh~</li>
</ul>

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/38389/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/14256/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/14256/" class="post-title-link" itemprop="url">设备使用细节 & 细碎日常 & 新版</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-19 19:06:29" itemprop="dateCreated datePublished" datetime="2019-10-19T19:06:29+08:00">2019-10-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:04" itemprop="dateModified" datetime="2022-06-03T21:45:04+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><ul>
<li>考察”日常”时发现一些问题, 这个新版主要是想解决这些问题才设置的.</li>
</ul>
<h1 id="以前存在哪些问题"><a href="#以前存在哪些问题" class="headerlink" title="以前存在哪些问题"></a>以前存在哪些问题</h1><ol>
<li>没有合适的归档整理, 导致混乱</li>
<li>内容在”技术”层面的纯度不足, 混杂了一些感想这种东西, 导致鱼龙混杂, 不好寻找(我个人不偏向鱼龙任何一方, 讨厌的对象只是混杂本身)</li>
</ol>
<h1 id="归档的协议"><a href="#归档的协议" class="headerlink" title="归档的协议"></a>归档的协议</h1><ol>
<li>每个月份更新下<code>##</code>小标题, 搜狗输入法输入ny(有教程自定义一下)</li>
<li>每天更新下<code>###</code>小标题, 搜狗输入法输入nyr(以后注意下, ny和nyr就是”年月”和”年月日”, 注释不能更新, 坑爹!)</li>
</ol>
<h1 id="记录什么内容"><a href="#记录什么内容" class="headerlink" title="记录什么内容"></a>记录什么内容</h1><ol>
<li>技术相关的问题&amp;思考&amp;解决方案&amp;待解决问题</li>
<li>复杂的配置过程&amp;注意事项</li>
<li>学习进程中自然产生的一些灵感or思索</li>
</ol>
<h1 id="不记录什么内容"><a href="#不记录什么内容" class="headerlink" title="不记录什么内容"></a>不记录什么内容</h1><ol>
<li>日常对人生&amp;对哲学的思考, 这些转移到日记中去, 避免污染</li>
<li>日常的心情和感受, 同样的理由, 同样的去处</li>
<li>对事件巧妙的处理办法(例如”更换时钟”一事), 主要是这些巧妙的处理办法与计算机技术无关, 也是转移到日记中去避免污染</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/14256/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/23181/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/23181/" class="post-title-link" itemprop="url">感觉写得很不错的一篇3100Report</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-15 15:01:04" itemprop="dateCreated datePublished" datetime="2019-10-15T15:01:04+08:00">2019-10-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:52:24" itemprop="dateModified" datetime="2022-06-03T21:52:24+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSC3100-Assignment-1-Report"><a href="#CSC3100-Assignment-1-Report" class="headerlink" title="CSC3100 Assignment 1 Report"></a>CSC3100 Assignment 1 Report</h1><h5> 姓名: `Sobadatsu Omo` </h5>
<h5> Student ID: `7182`</h5>

<h2 id="Decomposition-of-This-Problem"><a href="#Decomposition-of-This-Problem" class="headerlink" title="Decomposition of This Problem"></a><strong>Decomposition of This Problem</strong></h2><p>The problem is of a composite type. Through a simple decomposition method, we can divide this question into three smaller sections of more generic types. Firstly we need to <strong>read streams of a static scale</strong> through web servers. Secondly we need to <strong>find out the exact positions</strong> of two values of this stream of data. Thirdly we need to <strong>varify a prime number</strong> that was obtained by the subtraction of these two values.</p>
<h2 id="Solutions-for-Each-Section"><a href="#Solutions-for-Each-Section" class="headerlink" title="Solutions for Each Section"></a><strong>Solutions for Each Section</strong></h2><h3 id="Read-Streams-of-a-Static-Scale"><a href="#Read-Streams-of-a-Static-Scale" class="headerlink" title="Read Streams of a Static Scale"></a><strong>Read Streams of a Static Scale</strong></h3><p>To read streams of a static scale through web servers, which can be recognized as a common instance of I/O data transmission. To solve it, we can use Scanner datatype, which is a widely applied file handler and can deal with a wide range of data sorts. I used to stick on it, until a cutting-edged technique “BufferedReader” has been revealed by my two of my friends, Xieguochao and Linyukun. </p>
<p>The idea is that because the whole set of data streams is of the same datatype, so we do not need to worry about being interrupted by some strange data of different types that we do not have certain built-in methods to deal with. On the contract, as for “BufferedReader”, the lack of generic functions can be regarded as a good save without a dummy type examinations in this case.</p>
<p>What’s more, they have the same size which indicate that it can benefit memory alignment and block alignment. So it can be naturally designed to support buffers when dealing with a large scale of IO operations within high-speed devices and low-speed devices.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/23181/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/7487/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/7487/" class="post-title-link" itemprop="url">单个github账户写多个博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-07 05:47:59" itemprop="dateCreated datePublished" datetime="2019-10-07T05:47:59+08:00">2019-10-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:04" itemprop="dateModified" datetime="2022-06-03T21:45:04+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="发心"><a href="#发心" class="headerlink" title="发心"></a>发心</h1><ul>
<li>最近想写日记, 日记就不仅仅能够记录技术, 还能刻画内心情感上的成长, 那么需要再建一个日记博客</li>
<li>初步的想法是再次申请一个github账号进行专门的日记写作, 然而我潜在觉得此后保存公钥私钥会成为更大的问题,遂放弃</li>
<li>从<a target="_blank" rel="noopener" href="http://chitanda.me/2015/11/03/multiple-git-pages-in-one-github-account/">千反田酱</a>了解到github可以无限定义”项目主页”, 这实际上就是博客的雏形了</li>
</ul>
<h1 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h1><ul>
<li>网上流传的需要将项目名称改为gh-pages我自己没有证实, 故无法判断真假</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li><p>在md文件暴露的情况下, 如何做到加密?</p>
<ul>
<li><p><del>我没有pro账号, 因此github pages都必须要public,同时我还要将md源文件上传至同样public的hexo分支, 而市面上的插件, 往往需要将passwd明文写在md源文件中, 那坏蛋们只要看一看我hexo中的md源文件, 不就直接可以明文得知密码了吗? 那这个插件岂不是搞笑</del></p>
<p><del><code>(我说的就是你, hexo-blog-encrypt插件!密码必须明文放在md文件里才能上锁简直搞笑!)</code><del></del></del></p>
</li>
<li><p><del>需要找一款插件, 我可以将密码保存在本地文件中(或者新建一个private repo去存他也完全可以), 然后这些设置文件我可以不用上传, 在md文件中, 我只用写一条<code>encrypt:true</code>即可声明我使用了默认密码, 反正现在的我也只需要使用默认密码</del></p>
</li>
<li><p>(2019年10月7日08:00:13)上面这个家伙在胡言乱语, 我不认识他. =&gt; <code>你TM都有md文件了, 人家点选md在线预览不就完事了, 跟你有没有密码有何关系? 锁还没挂门上就先考虑钥匙, 唉~</code></p>
</li>
<li><p>其余更新在”加密更新”一栏</p>
</li>
</ul>
</li>
</ul>
<h1 id="以下警示-这些可以作为一篇新博客教程-但加密功能有误-相见”更新”-请注意"><a href="#以下警示-这些可以作为一篇新博客教程-但加密功能有误-相见”更新”-请注意" class="headerlink" title="以下警示, 这些可以作为一篇新博客教程, 但加密功能有误(相见”更新”)请注意!"></a><b>以下警示, 这些可以作为一篇新博客教程, 但加密功能有误(相见”更新”)请注意!</b></h1><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><b> 请务必按照步骤一步步实现 </b></p>
<h2 id="github-操作部分"><a href="#github-操作部分" class="headerlink" title="github 操作部分"></a>github 操作部分</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/7487/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/23067/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/23067/" class="post-title-link" itemprop="url">Haskell目前存在的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-03 23:58:50" itemprop="dateCreated datePublished" datetime="2019-10-03T23:58:50+08:00">2019-10-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:03" itemprop="dateModified" datetime="2022-06-03T21:45:03+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>388</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>在Win平台下找不到一款较好的IDE进行使用, 虽然Haskell一般也打不了多少字, 但是还是希望能够有IDE</li>
<li>函数类型签名及类型类的使用仍处于基本懵B状态, 只会观察报错信息来不断事后补充签名, 函数类型的确认也不很熟练, 在pp107_findIndices实现时不知道必须使用[Int]作为返回值类型, 其原因现在仍未搞清楚.</li>
<li>起步不到一个月, 像Monad和Just这种抽象知识欠缺过多.</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>今天尝试配一下Win emacs, 据群上说这个比较好用, 要达到:<ul>
<li>智能提示</li>
<li>自动补全</li>
<li>不需创建工程</li>
</ul>
</li>
<li>我们的目标暂时还不在这个类型系统上, 于是先放一放这个签名(毕竟就算不签名强大的Haskell类型推断系统也会帮你推出来的, 推不出来报错你也可以看得懂), 菜鸡还是要有菜鸡的自觉性好一些, 我先随缘签名了.</li>
<li>已经购买了TTPL和PLDS, 这个看完之后估计对Monad的认识就可以比较深入了, 书也不算厚.</li>
</ol>

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/23067/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/43211/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/43211/" class="post-title-link" itemprop="url">CppPrimer读书笔记-变量作用域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-18 16:11:49" itemprop="dateCreated datePublished" datetime="2019-09-18T16:11:49+08:00">2019-09-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:03" itemprop="dateModified" datetime="2022-06-03T21:45:03+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序中有些名字指向了多个对象, 这些同名对象通过作用域, 对这个名字宣誓不同时期的主权; 而某个对象特定的作用域, 也刻画了这个变量的创造与销毁的历程, 所以作用域就好像”心中的道德律, 或者头顶的星空”一样.</p>
<p>顺便说下, 菜鸟教程下方的笔记一定要看, 都是高手之言!</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-variable-scope.html#postcomments">菜鸟教程-C++变量作用域-9篇笔记</a></li>
<li>《C++ Primer第五版》</li>
<li>其他不列举了, 你们都是天使.</li>
</ul>
<h1 id="作用域是什么-作用域用于划分什么"><a href="#作用域是什么-作用域用于划分什么" class="headerlink" title="作用域是什么? 作用域用于划分什么?"></a>作用域是什么? 作用域用于划分什么?</h1><p>《C++ Primer第五版》pp184提到, 块构成一个新的作用域. 那么答案很明显了, 其实作用域就是一个个”块”, 常见的块就是”大括号里面包起来的部分”, 所以我们可以粗浅的理解为, 作用域就是有大括号里面包起来的部分. 实际上作用域不仅如此, 这里的”块”不仅仅指大括号内部的, “大括号”前的小括号, (像是函数形参表, loops的stmts部分)也要算进去, 因为他们都参与了内部的运算, 于是我们可以简单的统一一下, 尽管还是很粗暴:</p>
<p>作用域是大括号中的部分, 以及它所从属的小括号中的区域.</p>
<p>作用域主要的作用是, 划分同名变量对这个名字的使用权, 规定这个名字的使用期限. 一般来说, 程序中尽量不要出现同名变量比较好, 需要使用的临时变量, 按照特定的规则对其命名即可. 但是这件事的弊端也很明显, 就是名字不够用, 需要加入大量”辅助阅读”的”前缀后缀”来命名变量, 那么很多事情就可以预见了, 像之前提到的, “拉布拉多_Eq”, “京巴犬_Eq”,”金毛败犬_Eq”这样的情况就会出现(当然这是接口封装抽象不足的问题, 但很多时候名字不够用, 恰恰就反映出抽象不足的特点.)</p>
<p>举例子, 《C++ Primer第五版》pp184(英文版对应pp204)<br>中提到, “函数最外层作用域中的局部变量也不能使用与函数形参一样的名字”, 这点就很好理解了, 因为他们同属于一个作用域”函数最外层”这个作用域, 自然不能同名.</p>
<p>注意, 一个函数可以有内作用域(不止最外面那个), 外作用域和内作用域是不同的, 这时候就可以同名了, 具体见<a target="_blank" rel="noopener" href="https://help.semmle.com/wiki/display/CCPPOBJ/Declaration+hides+variable">这里</a>和<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30125671/what-does-local-variables-at-the-outermost-scope-of-the-function-may-not-use-th#30125743">这里</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/43211/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/4744/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/4744/" class="post-title-link" itemprop="url">CppPrimer代码评述1-Ch3_arrayScores-迭代器遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-16 20:51:01" itemprop="dateCreated datePublished" datetime="2019-09-16T20:51:01+08:00">2019-09-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:03" itemprop="dateModified" datetime="2022-06-03T21:45:03+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新坑是代码评述系列, 评述写在注释里, 非常主观非常粗俗, 但可能可以给我带来一点安慰, 感觉自己好勤奋的样子.</p>
<h2 id="碎碎念1-C-迭代器到底要实现什么-好在哪里"><a href="#碎碎念1-C-迭代器到底要实现什么-好在哪里" class="headerlink" title="碎碎念1-C++迭代器到底要实现什么?好在哪里?"></a>碎碎念1-C++迭代器到底要实现什么?好在哪里?</h2><p>这边先简单提一下C++的迭代器, 我们知道C++一共有5种(甚至更多?)种迭代器, 具体请看<a target="_blank" rel="noopener" href="https://blog.csdn.net/sim_szm/article/details/8980879">这里</a>, 但是归根结底, 在实现”遍历”这个事情上, 我们需要的迭代器只要能够实现这两点就足够贴心了:</p>
<ol>
<li>通用接口: <ul>
<li>对所有容器类与”类似容器类的类型”(比如String类型), 提供相似的接口(目前的实现, 就是T.begin(), T.end()两个成员函数)</li>
<li>对原生数组提供与容器类尽可能相似的操作.</li>
</ul>
</li>
<li>防越界: <ul>
<li>利用边界条件实现”迭代终止”的判断, 而不是依靠程序员自己判断<br>目前存在的问题是, 因为数组显然不是类型类, 所以不可能有T.begin(), T.end()这样的成员函数, 但是我们还是希望实现一个通用接口, 于是我们使用<code>&lt;iterator&gt;</code>里面的cbegin和cend两个成员函数, 他们接受数组并返回头尾指针(并且由于加c所以还是个常量, 省的以后多事), 如此一来, 我们就能够实现: 完完全全使用”迭代器”(或类似迭代器的”迭代指针常量”)进行遍历这一宏伟目标了, 我觉得有点像”百代皆从秦制”那种美感, 具体请看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37653144/article/details/78552479">这里</a></li>
</ul>
</li>
</ol>
<h2 id="碎碎念2-符号记法中的一些玄机"><a href="#碎碎念2-符号记法中的一些玄机" class="headerlink" title="碎碎念2-符号记法中的一些玄机"></a>碎碎念2-符号记法中的一些玄机</h2><p>这边再扯一点关于一些符号记法的东西, 首先我们知道每一种语言它的记号都是有一定区别的, 但是在这些区别中也是有通用的记法(或者干脆叫做”创造者们的一种默契”好了^_^), 这些通用的记法比如说都使用<code>[]</code>作为数组索引的算子; 不同的东西我们可以认为是某种特定的”Style风格”, 比如同样是定义普通数组, C/C++喜欢中置括号(C sytle), 而Java喜欢把括号提前(Java style), 这里面也大有玄机:<br>我猜测, 因为我们知道Java不像C++, 天天要拖着C这个弟弟然后无限纵容(兼容), 所以很快就走向了”容器”+”切面”这样的编程模式了(这也是为什么后面会形成那么多的编程范式的原因之一), 也就是”容器”这个更抽象的概念与思想很可能是Java先广泛运用的, 比如 <code>Int[]</code>, 很可能就体现出来一个”容器”的雏形, 因为这种写法就意味着<code>Int[]</code>与<code>Int</code>两个概念的分离, {“整型指针”, “整型数组”}是容器一类, {“整型”}是元素一类, 他们之间概念的差异被Java发扬出来, 这是一个体现.<br>我猜测,为什么C语言一开始定义数组使用中置括号, 可能与”内存操作”的印象有关, 因为本身”数组”的应用天生就与”遍历”分不开(sizeof我们都知道是”编译期决定”的, 所以也不能帮忙对数组长短进行控制), 然而从内存视角而言Int数组和Int差别其实不是很大(他们的指针都只能指向一个块块), 因此他们认为Int Array就是Int, 只是需要对后面的若干块进行管理, 这种想法很自然就不会将<code>[]</code>剃刀变量前面, 因为以这种内存观点来看, <code>[]</code>提前反而是一种误解了, 认为这个指针指向另一个数组指针了.</p>
<h2 id="碎碎念3-关于逗号与分号的使用分析"><a href="#碎碎念3-关于逗号与分号的使用分析" class="headerlink" title="碎碎念3-关于逗号与分号的使用分析"></a>碎碎念3-关于逗号与分号的使用分析</h2><p>代码后半部分注释进行了探讨, 在此不做过多说明.</p>
<h2 id="代码评述"><a href="#代码评述" class="headerlink" title="代码评述"></a>代码评述</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Retrieved from C++Primer5, S.B.Lippman</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::cbegin;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::cend;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意上面的写法, 用不同的include区分各自的类成员</span></span><br><span class="line"><span class="comment">// 我们很清晰地知道, size_t在&lt;cstddef&gt;里面, vector在&lt;vector&gt;里面, 而各种流对象cin, cout,和流操作子endl在&lt;iostream&gt;里面.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有点奇怪, grade一般指&quot;等级&quot;, 也就是 A,B,C这样子, 而score一般指具体的分数, 也就是97,87,77这样子</span></span><br><span class="line"><span class="comment">// 那么这个命名就出现问题了!!, 应该是vector&lt;unsigned&gt; scores才对! 而后面的grades应该才是进行++的对象!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; grades;</span><br><span class="line">	<span class="comment">// count the number of grades by clusters of ten:</span></span><br><span class="line">	<span class="comment">// 就是以10分为一个cluster(可以直接理解为一个group, 分成小组), 然后统计落在各个区间(小组)的人数</span></span><br><span class="line">	<span class="comment">// 0--9, 10--19, . . . 90--99, 100, 一共11个小组.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> sz = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> scores[sz] = &#123;&#125;;  <span class="comment">// 11 buckets, all value initialized to 0,</span></span><br><span class="line">	<span class="comment">// 疑问, 是什么实现了数组的自动初始化呢?</span></span><br><span class="line">	<span class="comment">// 这个scores应该命名为 numOfStudentsInDifferentClusters更好.</span></span><br><span class="line">	<span class="keyword">unsigned</span> grade;</span><br><span class="line">	<span class="comment">// 你们传参的时候, 可以传一些-1,-2什么的, 观察下溢出, 很好玩的.</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">		<span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">			<span class="comment">// 这边不用限制 负数 或者 字母 的情况, 因为这个在grade定义为unsigned的时候已经处理好了</span></span><br><span class="line">			<span class="comment">// increment the counter for the current cluster</span></span><br><span class="line">			++scores[grade/<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// grade/10 由于是截断除法, 所以可以覆盖从0-10共11个indices</span></span><br><span class="line">		<span class="comment">// 这边的scores相当于numOfStudentsInDifferentClusters, 在特定的分数段增加一个人的计数(++)</span></span><br><span class="line">		grades.push_back(grade);</span><br><span class="line">		<span class="comment">// push_back相当于append, push_head就相当于append_head</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;grades.size = &quot;</span> &lt;&lt; grades.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 这个地方顺便一提: size()是运行时确定的, 而sizeof()是编译时确定的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for every element in grades</span></span><br><span class="line">	<span class="comment">// C++05中对于string类和各种容器类（如vector等）添加了T.begin()和T.end()两个成员函数,</span></span><br><span class="line">	<span class="comment">// 于是遍历容器的办法就变成了都用迭代器了, 当然这样我们是很开心的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 个人建议所有的iterator迭代器全部用auto声明比较好, 因为类型名字太长了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt;::const_iterator g = grades.begin(); g != grades.end(); ++g)</span><br><span class="line">		<span class="comment">// 使用迭代器g对grades数组进行遍历, 迭代器也可以++(说明++也进行了重载)</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *g &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">	<span class="comment">// 迭代器本质上是一个指针, 但是因为能够使用begin()和end()方法, 所以不用担心越界, 因此更加安全</span></span><br><span class="line">	<span class="comment">// 尽量使用迭代器去遍历数组, 因为这样更加安全.</span></span><br><span class="line">	<span class="comment">// 做一个专题, 就是cpp的5类迭代器.</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for each counter in scores</span></span><br><span class="line">	<span class="comment">// 这个时候原生数组就比较弟弟了, 因为数组不是类类型</span></span><br><span class="line">	<span class="comment">// (数组array并不是容器或者string, 更加底层所以没有做T.begin()和T.end()的实现, 与C兼容也是其中一部分考虑)</span></span><br><span class="line">	<span class="comment">// 看看这里, 单纯为了找一个好的&quot;临时变量类型&quot;就得引入一个size_t, 虽然C语言的确一般都是这么做的, 但是C++这么做就显得非常awkwar了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != sz; ++i)</span><br><span class="line"> 	<span class="comment">// 这么写太搞笑了, 堂堂C++Primer这么写代码(可能是为了体现容器类型与普通数组的区别, 但其实可以换种方式实现)</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; scores[i] &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// print the value of that counter</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我自己的&quot;遍历普通数组&quot;的实现如下:引入&lt;iterator&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里cbegin()是因为我想做一个直接得到const, 防止一些乱七八糟的问题</span></span><br><span class="line">	<span class="keyword">auto</span> array_first=cbegin(scores);</span><br><span class="line">	<span class="comment">// 我也不管你前面用什么类型来做数组下标的, 反正涉及到迭代一律auto走起,</span></span><br><span class="line">    <span class="comment">// 因为我后续肯定也不需要用到这两个临时变量了, 所以使用auto合情合理.</span></span><br><span class="line">    <span class="comment">// 一点猜想, 此处类型应该是const size_t*, 我使用const size_t*, 编译是OK的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>* array_last=cend(scores);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里因为array_first和array_last已经进行过类型声明了, 所以不是for(auto ..)</span></span><br><span class="line">	<span class="comment">// 很多人有个误区呀, 就是觉得for的条件与传参类似, 实际上大错特错,</span></span><br><span class="line">	<span class="comment">// for里面的这个stmts实际就是普通的变量定义与变量赋值而已, 只是它的位置比较特殊, 他放在for的stmt里面</span></span><br><span class="line">	<span class="comment">// 但是函数传参不一样, 函数传参本质上是内部实现stack_frame时候需要的一个参数表</span></span><br><span class="line">	<span class="comment">// 这么举例, 就是for语句后面跟的就是普通的赋值语句, 跟的是很多个expressions组成的stmts, 所以它是使用分号隔开的</span></span><br><span class="line">	<span class="comment">// 而函数传参, 因为是传一个参数表, &quot;实际上可以理解为传入一个有很多形参的元组&quot;(学过Haskell的人就知道), 而元组是使用逗号隔开的</span></span><br><span class="line">	<span class="comment">// 所以函数传参和for循环搞不清楚到底用分号还是逗号的, 本质上就是没有把握住这个历史脉络, 还是想得太少了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(array_first;array_first!=array_last;array_first++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *array_first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/4744/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/18741/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/18741/" class="post-title-link" itemprop="url">Haskell类型类专题1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-15 15:36:19" itemprop="dateCreated datePublished" datetime="2019-09-15T15:36:19+08:00">2019-09-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:03" itemprop="dateModified" datetime="2022-06-03T21:45:03+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Haskell类型类既不是”类型”, 也不是”类型的类型”, 此处中文的”类型类”与英文的”Typeclass”都很confusing, 以下整理一些常见的问题及其解答(FAQ):{以下理解都非常粗浅, 因为我学这个不到2星期}</p>
<h2 id="类型类究竟是什么-和类型有什么联系"><a href="#类型类究竟是什么-和类型有什么联系" class="headerlink" title="类型类究竟是什么? 和类型有什么联系?"></a>类型类究竟是什么? 和类型有什么联系?</h2><ul>
<li>类型类与接口相似, 是类型的标杆.”入乡随俗”<ul>
<li>显示了类型的一些属性</li>
<li>赋予了类型一些功能</li>
<li>限制了类型的一些行为</li>
<li>不限死某种特定的”类型”</li>
</ul>
</li>
<li>虽然类型类与接口相似, 但是类型类本身可以完成缺省的函数实现, 也可以多继承, 给类型定义带来福利.<ul>
<li>给既有类型的福利:<ul>
<li>(这点存疑, 不确定)因为可以完成缺省函数实现(也就是Haskell内部已经定义而非仅仅声明), 所以这个抽象的”接口”实际上可以变成实际的”汽油机”, 也即我们不需要对接口进行自定义的Implement, 可以直接使用Haskell自身定义好的类型类.</li>
</ul>
</li>
<li>给新类型的福利:<ul>
<li>因为可以多继承, 所以newtype时候就可以直接detriving, 省下很多(像什么友元声明,单例继承一堆破事)的代码.</li>
</ul>
</li>
</ul>
</li>
<li>类似于C++的模板, 可以默认也可以特化.请看<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41270359/answer/90337677">这里</a></li>
</ul>
<h2 id="类型类能用来干什么"><a href="#类型类能用来干什么" class="headerlink" title="类型类能用来干什么?"></a>类型类能用来干什么?</h2><ul>
<li>给予某个新类型一些函数(或者算子,都一样), 例如<a target="_blank" rel="noopener" href="https://rwh.readthedocs.io/en/latest/chp/6.html#the-need-for-typeclasses">这里</a>定义的Color类型.<ul>
<li>因为Color是新定义类型(且字面值中没有数字或字符串这些东西,所以)没法被Haskell”类型推断机制”识别, 所以默认是不给Color任何类型类的, 那么”判断相等或不等”这件事就需要自己写函数, 3个颜色9种组合, 只有{RR}{GG}{BB}3种正确, 所以给出相等的定义.<ul>
<li>这种操作是低效的,按照C++观点就是没有对”相等”这件事进行重载, 事实上这个思想是共通的, 只是Haskell是用类型类来把”重载”这件事也给提取并抽象为类型类了</li>
<li>为什么不能不重载? 不重载的坏处是:<ul>
<li>假设我们是一个宠物专卖店, 有100种狗, 并且由于生理因素的划分必须每种狗都建立一种类型, 那么所有的判断”(狗的种类)是否相等”的函数就会有100种(类似”京巴狗_Eq”, “拉布拉多犬_Eq”, “金毛败犬_Eq”…)</li>
</ul>
</li>
<li>如果我的”相等”判定比较特殊(奇葩), 我判定的标准是: 例如{“拉布拉多犬”, “拉布拉多狗”, “拉布拉多”}三个字符串是可以认为他们”相等”的, 那这种情况要怎么处理?<ul>
<li>如果在C++中:<ul>
<li>在重载算子的时候请谨慎一点(推荐尽量不要重载算子)因为你到时候这个”=”一旦被继承, 根本不知道bug出在”犬”和”狗”的身上.</li>
</ul>
</li>
<li>如果在Haskell中, <ul>
<li>推荐单独写函数, 因为重载的算子实际上就是一种函数, 并且函数全局下只有一种定义(?存疑, 这点待求证), 我不确定会不会重载掉”=”之后全局的等号都会被污染.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>粗浅理解就是:<ul>
<li>引入算子:<ul>
<li>如果实现类型时要用到”=”, 那么请引入”Eq”类型类.</li>
</ul>
</li>
<li>注意类型类之间的依赖:<ul>
<li>如果要实现”&gt;”,”≥”, 那么请引入”Ord”的同时, 引入”Eq”, 因为”Ord”依赖着”Eq”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对某些”类型划分不单一”的字面量进行合理限制, 例子见《Haskell函数式编程入门-第二版-第一卷》51-52页<ul>
<li>举例: <code>:type 5</code> -&gt; <code>5 :: Num a =&gt; a</code></li>
<li>首先, 字面量分两种, 一种是具有明确类型的,一类是不具有明确类型的.<ul>
<li>具有单一类型的字面量:<ul>
<li>{‘a’, ‘b’, ‘c’}, 一定是Char类型</li>
<li>{True, False}, 一定是Bool类型</li>
</ul>
</li>
<li>类型划分不单一的字面量:<ul>
<li>数字5: 只能说一定得满足Num类型类要求, 但具体是哪种类型不确定.(视情况, 既可以是Int{8,16,32,64}, 也可以是Integer, 也可以是Int, 也可以是Float or Double)</li>
<li>字符列表”abc”: 只能说一定得满足<code>[Char]</code>类型类要求, 但具体是哪种类型不确定.(既可以是”字符串”也可以是”字节串”(ByteString))<ul>
<li>(和python2类似的老毛病) </li>
<li>(当然这个在C++和python3里面已经可以通过开头加一个b解决了)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了对这些字面量进行约束, 给字面量施加类型类约束, 这样字面值5既可以在各种场合以各种类型出现(而不需要类型转换), 又使得字面量得到了一定的限制, 例如5+”abc”会报错这样.</li>
<li>顺带一提, 因为5的类型划分不单一, 所以一些Haskell专家(见《Haskell函数式编程入门-第二版-第一卷》51-52页)直接把数字字面量视作”重载了的字面值”(overloaded literals)<ul>
<li>类似重载的行为: <ul>
<li>5作为一个”数字字面量”, 具有很多种类型, 相当于5在不同场合下自动进行了”类型重载”, 因此我们称5为”可重载的字面值”, 抑或”重载了的字面值”, 举例, 字面值5自身就可以作为Int和Integer两种类型, 不同场合就像被”自动化地重载”了一样</li>
</ul>
</li>
<li>类型类Num是从”类型集合”中提取出来的:<ul>
<li>虽然5没有确定的类型, 或者说5存在一个可供特定场合挑选的”(很多)类型(的)集合”, (集合长度&gt;=3), 但是这个集合中的每一个”类型”, 不管你是Int还是Float还是Integer, 都必须给我实现Num类型类接口, 因为这个集合中所有的元素(也即5可以挑选的所有的”类型”)都必须实现Num类型类接口, 所以5就因此必须实现Num类型类接口.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="目前存在的疑问"><a href="#目前存在的疑问" class="headerlink" title="目前存在的疑问"></a>目前存在的疑问</h2><ul>
<li><p>定义函数时, 限定语句<code>f :: Num a =&gt; a -&gt; a</code>存在的意义是”双重保险”吗? 能不能删除?</p>
<ul>
<li>在不严谨的场合下, 是否可以省略?<ul>
<li>例子, 我自己写斐波那契函数没写这行, runghc也不报错</li>
</ul>
</li>
<li>在严谨的场合下, 到底要多严谨?<ul>
<li>因为”Haskell类型推断系统”肯定很厉害, 那么他应该会帮我检查出类型的错误才对, 那么我再写一遍这个”限定语句”有两种情况:<ol>
<li>我菜, 比推断系统想得少, 没有很好地限制死函数类型, 导致多态应用出错, 而如果我装傻不写, 这个错误就会在编译时被检查出来(存疑?不知道是不是编译时检查?), 怎样才是好的做法?</li>
<li>我自作聪明, (在特定需求下定制参数类型)比推断系统想得多, 但是如果限制得比较死(比如RGB参数限制在Word8这种比较小的区间下, 这个倒是Best Pratice, 我举不出那种”取值区间本没必要限制得那么死”例子, 反正就是这个意思),据说<a target="_blank" rel="noopener" href="https://www.douban.com/group/topic/23342792/#291372451">编译器特定优化后效率可得到提升</a>, 这样要是以后需要”泛化版本”会不会带来麻烦?<ul>
<li>我不知道这个”范围限制”到底是我的责任还是Haskell推断系统的责任?</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>既然声明类型变量(type-variables)时可以随意选用字母, 为什么在这里没有出一套naming conventions这样的限制来约束代码, 增强函数的可读性?</p>
</li>
</ul>
<h2 id="参考网站-amp-参考书"><a href="#参考网站-amp-参考书" class="headerlink" title="参考网站 &amp; 参考书"></a>参考网站 &amp; 参考书</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/group/topic/23342792">Haskell新手FAQ</a></li>
<li><a target="_blank" rel="noopener" href="https://rwh.readthedocs.io/en/latest/chp/6.html">Real world Haskell-类型类</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.jikexueyuan.com/project/haskell-guide/build-our-own-type-and-typeclass.html">构造我们自己的 Types 和 Typeclasses</a></li>
<li>《Haskell函数式编程入门-第二版-第一卷》</li>
</ul>

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/18741/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/6355/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/6355/" class="post-title-link" itemprop="url">Haskell入门-知识杂记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-06 20:57:50" itemprop="dateCreated datePublished" datetime="2019-09-06T20:57:50+08:00">2019-09-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:03" itemprop="dateModified" datetime="2022-06-03T21:45:03+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>初窥门径, 长期更新</p>
<h2 id="GHC"><a href="#GHC" class="headerlink" title="GHC"></a>GHC</h2><ul>
<li>GHC=ghc(编译器)+ghci(i=interactive, 交互式)+runghc(解释器, 不需要编译)</li>
</ul>
<h2 id="ghci"><a href="#ghci" class="headerlink" title="ghci"></a>ghci</h2><ul>
<li>i=interactive, 交互式</li>
<li>类似于python的IDLE, 同时也都有调试功能.</li>
<li>交互式Shell都有调试功能吗?</li>
</ul>
<h3 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h3><ul>
<li>Prelude是一个常用模块, 这里<code>Prelude&gt;</code> 表示预加载了Prelude模块</li>
<li>加载其他模块:<ul>
<li>指令: <code>:module 模块名&#123;例如, Data.Ratio&#125;</code>或者<code>:m 模块名&#123;例如, Data.Ratio&#125;</code></li>
<li>prompt增长: <code>Prelude&gt;</code> -&gt; <code>Prelude Data.Ratio&gt;</code></li>
</ul>
</li>
<li>Prelude提示符的替代:<ul>
<li>指令: <code>:set prompt &quot;ghci&gt;&quot;</code></li>
<li>可以乱写: <code>:set prompt &quot;sangaizhonggai&gt;&quot;</code></li>
<li>静态效果: 改完后导入模块不显示导入名.</li>
<li>重置指令: <code>:unset prompt</code></li>
</ul>
</li>
<li>建议:<ul>
<li>prompt增长起到了提示功能, 我认为有利</li>
<li>(除非左边太长)不建议瞎改成其他名字, 没什么意义</li>
</ul>
</li>
</ul>
<h3 id="ghci运算符"><a href="#ghci运算符" class="headerlink" title="ghci运算符"></a>ghci运算符</h3><ul>
<li>Haskell除法默认不floor, 不截断<ul>
<li>例子: 7/2=3.5</li>
</ul>
</li>
<li>数学上,二元运算符(binary operator)可摆放在运算数(operand)的不同位置, 分成3类:<ul>
<li>前缀运算符, 中缀运算符, 后缀运算符(自然对应3种表达式, 不多提)</li>
<li>这些”缀”只适用于二元运算符, 其他{1元}或{3元及以上}都不行</li>
</ul>
</li>
<li>Haskell不支持后缀表达式, 比如<code>5!</code>这种就没有.</li>
<li>Haskell下前中缀转换:<ul>
<li>前缀(prefix)转中缀(infix): 用”`”包起来</li>
<li>中缀(infix)转前缀(prefix): 用小括号包起来</li>
</ul>
</li>
<li>Hasekll不等号是”/=”(正斜杠+等号)而不是”!=”<ul>
<li>(想起之前有人问什么是正反斜杠: 斜率k&gt;0是正斜杠, k&lt;0是反斜杠^_^)</li>
</ul>
</li>
<li>Haskell运算符一览表<ul>
<li>初中数学老师: “表的好处有啥子呦↘一目↗了然↘一遍↗就记住~忘了↗就查↘”</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/haskell-operators.pdf">Haskell运算符一览表</a></li>
</ul>
</li>
<li>注意事项<ul>
<li>Haskell没有赋值行为, “-“是唯一的一元运算符, 表示”将减号作用于operand”</li>
<li>能写括号就不要懒, 不多提</li>
</ul>
</li>
</ul>
<h2 id="2019年9月6日23-00-45-待解决问题"><a href="#2019年9月6日23-00-45-待解决问题" class="headerlink" title="(2019年9月6日23:00:45) 待解决问题:"></a>(2019年9月6日23:00:45) 待解决问题:</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/6355/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/53092/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkeer365">
      <meta itemprop="description" content="可能会高产, 可能会暂停, 但长期来看总会更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无限求知的Master Spark">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/53092/" class="post-title-link" itemprop="url">在windows下使用stack配置基于vscode的简易版Haskell开发环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-06 16:12:29" itemprop="dateCreated datePublished" datetime="2019-09-06T16:12:29+08:00">2019-09-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 21:45:04" itemprop="dateModified" datetime="2022-06-03T21:45:04+08:00">2022-06-03</time>
      </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Haskell的IDE稀少且难以配置,从前天至今日累计花费6小时才成功,以下是配置记录. </p>
<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul>
<li>(先吐个槽,许多教程漏洞百出, 浪费大家时间, 此处先看我推荐的这些网站, 避免走弯路)</li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018257284">蒟蒻中蒟蒻</a><ul>
<li>虽是在*nix下的, 但是windows也适用.</li>
<li>这篇文章步骤存在一定问题: 在看完全文前请不要提前操作!</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/hellmonky/note/blob/master/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%85%B3%E4%BA%8Evscode%E6%90%AD%E5%BB%BAh%E7%8E%AF%E5%A2%83%E7%9A%84%E8%BF%87%E7%A8%8B.md">hellmonky</a><ul>
<li>这篇文章很不错, 但该篇侧重”Haskell工程项目”的IDE搭建, 与本篇所介绍的”简易版”有所出入.</li>
<li>这篇文章适合”使用Haskell创建大型项目”的用户参考, 再次重申, 本文搭建的是”简易版”开发环境.</li>
</ul>
</li>
</ul>
<h1 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a>当前环境</h1><ul>
<li>Windows 10.0.17763</li>
</ul>
<h1 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h1><ul>
<li>stack安装</li>
<li>vscode下Haskell插件5个依赖程序安装</li>
<li>vscode插件路径配置与hs程序调试</li>
</ul>
<h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ul>
<li>参考第一篇<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018257284">蒟蒻中蒟蒻</a></li>
<li>安装stack: 点<a target="_blank" rel="noopener" href="https://docs.haskellstack.org/en/stable/install_and_upgrade">这里</a>进行下载.<ul>
<li>我个人希望stack自动更新, 所以我默认安装C盘, 想安装在D盘的朋友请看<a target="_blank" rel="noopener" href="https://notes.shinemic.cn/setting-up-haskell-stack-development-environment/">这篇文章</a></li>
<li>我个人喜欢自己操作Path环境变量, 所以安装过程中有2个自动Add Path to C:/sc的选项我没有涂黑勾选, 类似下图这样:</li>
<li><img src="/53092/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E4%B8%A4%E4%B8%AA%E9%83%BD%E4%B8%8D%E9%80%89.jpg" class title="stack安装过程-两个都不选"></li>
</ul>
</li>
<li>设置环境变量: Path里头加入stack.exe所在文件夹, <ul>
<li>此处设置环境变量意图为: 为stack install提供便利(即不比麻烦地cd到文件夹下)</li>
<li>其实你们要是会用listary的话, 直接<ul>
<li>双击ctrl, 弹出search bar</li>
<li>exe:stack, 找到这个stack.exe文件</li>
<li>ctrl+shift+D, 复制文件所在文件夹到剪贴板中</li>
<li>在Path中粘贴, 一气呵成.</li>
</ul>
</li>
</ul>
</li>
<li>检查cmd下键入stack有没有长长的段落跳出, 有的话执行<code>stack install</code>和<code>stack upgrade</code></li>
<li>需要跳过的选项:<ul>
<li>“使用stack创建你的project”这一栏, stack new, stack setup到stack exec my-project-exe统统不需要!<ul>
<li>原因: 我们搭建的是”简易版”开发环境, 只需要以下功能:<ul>
<li>ghci能交互式运行</li>
<li>在智能提示环境下写好单个hs文件后, 能够运行并调试</li>
</ul>
</li>
<li>那个stack new等等是针对一个大型工程的, 我们不需要.</li>
</ul>
</li>
<li>跳过换源<ul>
<li>原因: 同上</li>
</ul>
</li>
</ul>
</li>
<li>直接来到”搭建vscode”这一栏:<ul>
<li>安装插件: Haskell Syntax Highlighting、Haskell ghc-mod 、haskell-linter、Haskelly;共4个</li>
<li>安装插件依赖: ghc-mod、hlint、intero、QuickCheck、stack-run;共5个<ul>
<li>先安装ghc-mod, 请直接使用这个命令:<ul>
<li><code>stack install ghc-mod --resolver lts-8.24</code></li>
<li>有人会问道stack install后我们已经有lts-14, 请放心, 他们会和平共处的</li>
</ul>
</li>
<li>安装好ghc-mod之后, stack会自动调用ltf-8.24版本, 此时后面的4个插件hlint、intero、QuickCheck、stack-run一定可以一气呵成安装好!</li>
</ul>
</li>
</ul>
</li>
<li>vscode插件路径配置<ul>
<li>新建文件夹HaskellProjects, 加入workplace.</li>
<li>File-Preference-settings里面搜索haskell.ghcMod.executablePath和haskell.hlint.executablePath两项<ul>
<li>在ghcMod和hlint下分别直接填写ghc-mod和hlint!</li>
</ul>
</li>
</ul>
</li>
<li>设置环境变量: Path里头分别加入hlint.exe所在文件夹和ghc-mod.exe文件夹<ul>
<li>一般是同一文件夹, 不同就都加一遍</li>
<li>此处设置环境变量意图为: vscode会自动读取环境变量中的hlint和ghc-mod, 也就是haskell.ghcMod.executablePath和haskell.hlint.executablePath两项会被自动补全!</li>
</ul>
</li>
<li>在HaskellProjects下新建feibonaqi.hs文件<ul>
<li>代码是:  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Main (<span class="title">main</span>) <span class="keyword">where</span></span><br><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n <span class="number">-1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = print $ fib <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li>运行, 成功会返回55.</li>
</ul>
</li>
<li>过河拆桥, 卸载stack<ul>
<li>原因: <ul>
<li>两人幸终: <ul>
<li>stack只是一个类似python中的pip程序, 只是一个托管者.在python-pip-vscode三者之间, 显然没有pip不影响python和vscode</li>
<li>基于这样的逻辑, stack可以出局, 只要Haskell和vscode两人幸终即可.</li>
</ul>
</li>
<li>stack工具人身份:<ul>
<li>依我之见,配置IDE实质:<ul>
<li>使用ghc解释(或解释)并运行hs程序.</li>
<li>利用vscode插件, 对Haskell代码的编写提供智能提示.</li>
</ul>
</li>
<li>正因如此, stack仅仅只是用来安装ghc-mod之类的工具人而已</li>
</ul>
</li>
</ul>
</li>
<li>注意事项:<ul>
<li>不要把compilers也选了, 不然你的ghc.exe会被误杀!</li>
<li>卸载选项图示:<ul>
<li><img src="/53092/%E5%8D%B8%E8%BD%BDstack.jpg" class title="注意compilers那项不要选!"></li>
</ul>
</li>
<li>万一一不小心把compilers也卸载了, 补救办法:<ul>
<li>此时插件已经齐了, 只是缺少ghc解释器</li>
<li>直接安装一个Haskell Platform,ghc会随之安装好,其他不用动</li>
<li>(需要环境变量就配置一下)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="GHCI安装"><a href="#GHCI安装" class="headerlink" title="GHCI安装"></a>GHCI安装</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/53092/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linkeer365</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">64k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">58 分钟</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//unpkg.com/animejs@3.2.1/lib/anime.min.js"></script>
<script src="//unpkg.com/hexo-theme-next@8.1.0/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-next@8.1.0/source/js/motion.js"></script><script src="//unpkg.com/hexo-theme-next@8.1.0/source/js/next-boot.js"></script>

  

<script src="//unpkg.com/hexo-theme-next@8.1.0/source/js/local-search.js"></script>






  






</body>
</html>
