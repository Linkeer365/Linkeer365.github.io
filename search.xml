<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CppPrimer代码评述1-Ch3_arrayScores-迭代器遍历</title>
    <url>/4744/</url>
    <content><![CDATA[<p>新坑是代码评述系列, 评述写在注释里, 非常主观非常粗俗, 但可能可以给我带来一点安慰, 感觉自己好勤奋的样子.</p>
<h2 id="碎碎念1-C-迭代器到底要实现什么-好在哪里"><a href="#碎碎念1-C-迭代器到底要实现什么-好在哪里" class="headerlink" title="碎碎念1-C++迭代器到底要实现什么?好在哪里?"></a>碎碎念1-C++迭代器到底要实现什么?好在哪里?</h2><p>这边先简单提一下C++的迭代器, 我们知道C++一共有5种(甚至更多?)种迭代器, 具体请看<a href="https://blog.csdn.net/sim_szm/article/details/8980879">这里</a>, 但是归根结底, 在实现”遍历”这个事情上, 我们需要的迭代器只要能够实现这两点就足够贴心了:</p>
<ol>
<li>通用接口: <ul>
<li>对所有容器类与”类似容器类的类型”(比如String类型), 提供相似的接口(目前的实现, 就是T.begin(), T.end()两个成员函数)</li>
<li>对原生数组提供与容器类尽可能相似的操作.</li>
</ul>
</li>
<li>防越界: <ul>
<li>利用边界条件实现”迭代终止”的判断, 而不是依靠程序员自己判断<br>目前存在的问题是, 因为数组显然不是类型类, 所以不可能有T.begin(), T.end()这样的成员函数, 但是我们还是希望实现一个通用接口, 于是我们使用<code>&lt;iterator&gt;</code>里面的cbegin和cend两个成员函数, 他们接受数组并返回头尾指针(并且由于加c所以还是个常量, 省的以后多事), 如此一来, 我们就能够实现: 完完全全使用”迭代器”(或类似迭代器的”迭代指针常量”)进行遍历这一宏伟目标了, 我觉得有点像”百代皆从秦制”那种美感, 具体请看<a href="https://blog.csdn.net/qq_37653144/article/details/78552479">这里</a></li>
</ul>
</li>
</ol>
<h2 id="碎碎念2-符号记法中的一些玄机"><a href="#碎碎念2-符号记法中的一些玄机" class="headerlink" title="碎碎念2-符号记法中的一些玄机"></a>碎碎念2-符号记法中的一些玄机</h2><p>这边再扯一点关于一些符号记法的东西, 首先我们知道每一种语言它的记号都是有一定区别的, 但是在这些区别中也是有通用的记法(或者干脆叫做”创造者们的一种默契”好了^_^), 这些通用的记法比如说都使用<code>[]</code>作为数组索引的算子; 不同的东西我们可以认为是某种特定的”Style风格”, 比如同样是定义普通数组, C/C++喜欢中置括号(C sytle), 而Java喜欢把括号提前(Java style), 这里面也大有玄机:<br>我猜测, 因为我们知道Java不像C++, 天天要拖着C这个弟弟然后无限纵容(兼容), 所以很快就走向了”容器”+”切面”这样的编程模式了(这也是为什么后面会形成那么多的编程范式的原因之一), 也就是”容器”这个更抽象的概念与思想很可能是Java先广泛运用的, 比如 <code>Int[]</code>, 很可能就体现出来一个”容器”的雏形, 因为这种写法就意味着<code>Int[]</code>与<code>Int</code>两个概念的分离, {“整型指针”, “整型数组”}是容器一类, {“整型”}是元素一类, 他们之间概念的差异被Java发扬出来, 这是一个体现.<br>我猜测,为什么C语言一开始定义数组使用中置括号, 可能与”内存操作”的印象有关, 因为本身”数组”的应用天生就与”遍历”分不开(sizeof我们都知道是”编译期决定”的, 所以也不能帮忙对数组长短进行控制), 然而从内存视角而言Int数组和Int差别其实不是很大(他们的指针都只能指向一个块块), 因此他们认为Int Array就是Int, 只是需要对后面的若干块进行管理, 这种想法很自然就不会将<code>[]</code>剃刀变量前面, 因为以这种内存观点来看, <code>[]</code>提前反而是一种误解了, 认为这个指针指向另一个数组指针了.</p>
<h2 id="碎碎念3-关于逗号与分号的使用分析"><a href="#碎碎念3-关于逗号与分号的使用分析" class="headerlink" title="碎碎念3-关于逗号与分号的使用分析"></a>碎碎念3-关于逗号与分号的使用分析</h2><p>代码后半部分注释进行了探讨, 在此不做过多说明.</p>
<h2 id="代码评述"><a href="#代码评述" class="headerlink" title="代码评述"></a>代码评述</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Retrieved from C++Primer5, S.B.Lippman</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::cbegin;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::cend;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意上面的写法, 用不同的include区分各自的类成员</span></span><br><span class="line"><span class="comment">// 我们很清晰地知道, size_t在&lt;cstddef&gt;里面, vector在&lt;vector&gt;里面, 而各种流对象cin, cout,和流操作子endl在&lt;iostream&gt;里面.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有点奇怪, grade一般指&quot;等级&quot;, 也就是 A,B,C这样子, 而score一般指具体的分数, 也就是97,87,77这样子</span></span><br><span class="line"><span class="comment">// 那么这个命名就出现问题了!!, 应该是vector&lt;unsigned&gt; scores才对! 而后面的grades应该才是进行++的对象!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; grades;</span><br><span class="line">	<span class="comment">// count the number of grades by clusters of ten:</span></span><br><span class="line">	<span class="comment">// 就是以10分为一个cluster(可以直接理解为一个group, 分成小组), 然后统计落在各个区间(小组)的人数</span></span><br><span class="line">	<span class="comment">// 0--9, 10--19, . . . 90--99, 100, 一共11个小组.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> sz = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> scores[sz] = &#123;&#125;;  <span class="comment">// 11 buckets, all value initialized to 0,</span></span><br><span class="line">	<span class="comment">// 疑问, 是什么实现了数组的自动初始化呢?</span></span><br><span class="line">	<span class="comment">// 这个scores应该命名为 numOfStudentsInDifferentClusters更好.</span></span><br><span class="line">	<span class="keyword">unsigned</span> grade;</span><br><span class="line">	<span class="comment">// 你们传参的时候, 可以传一些-1,-2什么的, 观察下溢出, 很好玩的.</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">		<span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">			<span class="comment">// 这边不用限制 负数 或者 字母 的情况, 因为这个在grade定义为unsigned的时候已经处理好了</span></span><br><span class="line">			<span class="comment">// increment the counter for the current cluster</span></span><br><span class="line">			++scores[grade/<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// grade/10 由于是截断除法, 所以可以覆盖从0-10共11个indices</span></span><br><span class="line">		<span class="comment">// 这边的scores相当于numOfStudentsInDifferentClusters, 在特定的分数段增加一个人的计数(++)</span></span><br><span class="line">		grades.push_back(grade);</span><br><span class="line">		<span class="comment">// push_back相当于append, push_head就相当于append_head</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;grades.size = &quot;</span> &lt;&lt; grades.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 这个地方顺便一提: size()是运行时确定的, 而sizeof()是编译时确定的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for every element in grades</span></span><br><span class="line">	<span class="comment">// C++05中对于string类和各种容器类（如vector等）添加了T.begin()和T.end()两个成员函数,</span></span><br><span class="line">	<span class="comment">// 于是遍历容器的办法就变成了都用迭代器了, 当然这样我们是很开心的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 个人建议所有的iterator迭代器全部用auto声明比较好, 因为类型名字太长了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt;::const_iterator g = grades.begin(); g != grades.end(); ++g)</span><br><span class="line">		<span class="comment">// 使用迭代器g对grades数组进行遍历, 迭代器也可以++(说明++也进行了重载)</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *g &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">	<span class="comment">// 迭代器本质上是一个指针, 但是因为能够使用begin()和end()方法, 所以不用担心越界, 因此更加安全</span></span><br><span class="line">	<span class="comment">// 尽量使用迭代器去遍历数组, 因为这样更加安全.</span></span><br><span class="line">	<span class="comment">// 做一个专题, 就是cpp的5类迭代器.</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for each counter in scores</span></span><br><span class="line">	<span class="comment">// 这个时候原生数组就比较弟弟了, 因为数组不是类类型</span></span><br><span class="line">	<span class="comment">// (数组array并不是容器或者string, 更加底层所以没有做T.begin()和T.end()的实现, 与C兼容也是其中一部分考虑)</span></span><br><span class="line">	<span class="comment">// 看看这里, 单纯为了找一个好的&quot;临时变量类型&quot;就得引入一个size_t, 虽然C语言的确一般都是这么做的, 但是C++这么做就显得非常awkwar了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != sz; ++i)</span><br><span class="line"> 	<span class="comment">// 这么写太搞笑了, 堂堂C++Primer这么写代码(可能是为了体现容器类型与普通数组的区别, 但其实可以换种方式实现)</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; scores[i] &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// print the value of that counter</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我自己的&quot;遍历普通数组&quot;的实现如下:引入&lt;iterator&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里cbegin()是因为我想做一个直接得到const, 防止一些乱七八糟的问题</span></span><br><span class="line">	<span class="keyword">auto</span> array_first=cbegin(scores);</span><br><span class="line">	<span class="comment">// 我也不管你前面用什么类型来做数组下标的, 反正涉及到迭代一律auto走起,</span></span><br><span class="line">    <span class="comment">// 因为我后续肯定也不需要用到这两个临时变量了, 所以使用auto合情合理.</span></span><br><span class="line">    <span class="comment">// 一点猜想, 此处类型应该是const size_t*, 我使用const size_t*, 编译是OK的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>* array_last=cend(scores);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意这里因为array_first和array_last已经进行过类型声明了, 所以不是for(auto ..)</span></span><br><span class="line">	<span class="comment">// 很多人有个误区呀, 就是觉得for的条件与传参类似, 实际上大错特错,</span></span><br><span class="line">	<span class="comment">// for里面的这个stmts实际就是普通的变量定义与变量赋值而已, 只是它的位置比较特殊, 他放在for的stmt里面</span></span><br><span class="line">	<span class="comment">// 但是函数传参不一样, 函数传参本质上是内部实现stack_frame时候需要的一个参数表</span></span><br><span class="line">	<span class="comment">// 这么举例, 就是for语句后面跟的就是普通的赋值语句, 跟的是很多个expressions组成的stmts, 所以它是使用分号隔开的</span></span><br><span class="line">	<span class="comment">// 而函数传参, 因为是传一个参数表, &quot;实际上可以理解为传入一个有很多形参的元组&quot;(学过Haskell的人就知道), 而元组是使用逗号隔开的</span></span><br><span class="line">	<span class="comment">// 所以函数传参和for循环搞不清楚到底用分号还是逗号的, 本质上就是没有把握住这个历史脉络, 还是想得太少了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(array_first;array_first!=array_last;array_first++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *array_first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/54047747/answer/137755282">强推!!-迭代器与指针的区别</a></li>
<li><a href="https://blog.csdn.net/sim_szm/article/details/8980879">C++五种迭代器</a></li>
<li><a href="https://blog.csdn.net/qq_37653144/article/details/78552479">C++迭代器遍历数组与容器</a></li>
<li><a href="https://zh.wikibooks.org/zh-hans/C%2B%2B/STL/Iterator#5%E4%B8%AA%E4%BD%9C%E4%B8%BAiterator_tag%E7%9A%84%E7%A9%BA%E7%B1%BB">wiki-C++迭代器</a></li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>CppPrimer读书笔记</tag>
        <tag>迭代器</tag>
        <tag>代码评述系列</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer读书笔记-变量作用域</title>
    <url>/43211/</url>
    <content><![CDATA[<p>程序中有些名字指向了多个对象, 这些同名对象通过作用域, 对这个名字宣誓不同时期的主权; 而某个对象特定的作用域, 也刻画了这个变量的创造与销毁的历程, 所以作用域就好像”心中的道德律, 或者头顶的星空”一样.</p>
<p>顺便说下, 菜鸟教程下方的笔记一定要看, 都是高手之言!</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/cplusplus/cpp-variable-scope.html#postcomments">菜鸟教程-C++变量作用域-9篇笔记</a></li>
<li>《C++ Primer第五版》</li>
<li>其他不列举了, 你们都是天使.</li>
</ul>
<h1 id="作用域是什么-作用域用于划分什么"><a href="#作用域是什么-作用域用于划分什么" class="headerlink" title="作用域是什么? 作用域用于划分什么?"></a>作用域是什么? 作用域用于划分什么?</h1><p>《C++ Primer第五版》pp184提到, 块构成一个新的作用域. 那么答案很明显了, 其实作用域就是一个个”块”, 常见的块就是”大括号里面包起来的部分”, 所以我们可以粗浅的理解为, 作用域就是有大括号里面包起来的部分. 实际上作用域不仅如此, 这里的”块”不仅仅指大括号内部的, “大括号”前的小括号, (像是函数形参表, loops的stmts部分)也要算进去, 因为他们都参与了内部的运算, 于是我们可以简单的统一一下, 尽管还是很粗暴:</p>
<p>作用域是大括号中的部分, 以及它所从属的小括号中的区域.</p>
<p>作用域主要的作用是, 划分同名变量对这个名字的使用权, 规定这个名字的使用期限. 一般来说, 程序中尽量不要出现同名变量比较好, 需要使用的临时变量, 按照特定的规则对其命名即可. 但是这件事的弊端也很明显, 就是名字不够用, 需要加入大量”辅助阅读”的”前缀后缀”来命名变量, 那么很多事情就可以预见了, 像之前提到的, “拉布拉多_Eq”, “京巴犬_Eq”,”金毛败犬_Eq”这样的情况就会出现(当然这是接口封装抽象不足的问题, 但很多时候名字不够用, 恰恰就反映出抽象不足的特点.)</p>
<p>举例子, 《C++ Primer第五版》pp184(英文版对应pp204)<br>中提到, “函数最外层作用域中的局部变量也不能使用与函数形参一样的名字”, 这点就很好理解了, 因为他们同属于一个作用域”函数最外层”这个作用域, 自然不能同名.</p>
<p>注意, 一个函数可以有内作用域(不止最外面那个), 外作用域和内作用域是不同的, 这时候就可以同名了, 具体见<a href="https://help.semmle.com/wiki/display/CCPPOBJ/Declaration+hides+variable">这里</a>和<a href="https://stackoverflow.com/questions/30125671/what-does-local-variables-at-the-outermost-scope-of-the-function-may-not-use-th#30125743">这里</a></p>
<h1 id="全局变量-amp-局部变量-amp-临时变量"><a href="#全局变量-amp-局部变量-amp-临时变量" class="headerlink" title="全局变量 &amp; 局部变量 &amp; 临时变量"></a>全局变量 &amp; 局部变量 &amp; 临时变量</h1><p>随便说一下, 有的小伙伴老在一些很奇怪的地方犯迷糊, 指明一些误区:</p>
<h2 id="main里面定义的变量不是全局变量"><a href="#main里面定义的变量不是全局变量" class="headerlink" title="main里面定义的变量不是全局变量"></a>main里面定义的变量不是全局变量</h2><p>main里面定义的变量是局部变量, 因为main也是函数, 只是程序从main这边进入而已. 很多小伙伴们认为, 程序运行时直接从main开始, 这点不错, 但是不够严谨, 如果这么说,那么”预加载”为什么不放在main函数里面呢? 严谨的说法在此处:<a href="https://zh.cppreference.com/w/cpp/language/main_function">搜索-静态存储期</a></p>
<p>也就是程序是在先完成对”全局变量”的定义(初始化)之后, 再进入main函数的, 这说明全局变量一定在main函数外部.看起来, 有的小伙伴们把main神圣化了(我们从上面那个链接可以看出main函数的确地位尊贵不可亵玩, 但还是比不了静态存储区的全局变量的)</p>
<h2 id="为什么全局变量一定要在所有函数定义前声明"><a href="#为什么全局变量一定要在所有函数定义前声明" class="headerlink" title="为什么全局变量一定要在所有函数定义前声明"></a>为什么全局变量一定要在所有函数定义前声明</h2><p>全局变量不一定”全局”,其作用域起点在他自己被定义的地方.</p>
<p>全局变量在main之前就被放在存储区中, 之所以成为全局变量是因为”没人敢杀”, 直到程序结束前谁都无权销毁全局变量, 而不是因为在”全局”都能起作用, 但是它并不能影响在它定义之前的代码,比如这个例子<a href="https://www.runoob.com/cplusplus/cpp-variable-scope.html#comment-24445">全局变量定义在函数后边</a>, 这里编译会报错, 找不到全局变量a, 理由很简单, 因为这个时候a还没有定义, 编译器看到我们使用一个没有定义的变量当然会报错.</p>
<p>有的小伙伴再问, 程序运行不是从main开始的吗? 就算是”先定义全局变量, 再从main开始, 再到各个函数”, 此时全局变量a应该早就定义完成了呀?说清楚一点, 他的理解是这样的:</p>
<p>执行-看到函数(跳过)-看到全局变量(放到静态区)-看到main(开始执行)-执行-好了</p>
<p>这里误区非常多(我自己可能也有很多误区), 简单说一点, 就是编译器的编译过程是从上到下, 并且依次检查你各个变量的使用情况的, (因为已经读到了函数定义部分, 编译器觉得要认真起来了, 于是)函数体中使用未声明的变量它看到后直接找静态区(看下是不是使用了全局变量), 静态区里面有那就OK, 没有的话就<code>&#39;::a&#39; has not been declared</code>直接报错未声明变量, 这么说来, 在全局变量还没有被读到并定义时, 编译器报错也是理所当然.</p>
<p>事实上, C语言比C++在此处更加严厉, C语言是连同函数都必须前文声明的, 如果函数A定义在后面, 然后定义在前面的函数B调用了A, 那么必须在B之前写一遍A的声明, 具体见<a href="http://c.biancheng.net/cpp/html/3241.html">这里</a>(我隐约觉得C语言可能连函数也放在静态区之中了??)</p>
<h2 id="变量与函数的声明有什么好处"><a href="#变量与函数的声明有什么好处" class="headerlink" title="变量与函数的声明有什么好处"></a>变量与函数的声明有什么好处</h2><p>尽管如此, 对付这种情况我们也有办法,就是把全局变量放在最前面进行声明, 但更好的办法则是, 写一个声明符号extern表示这个变量我只是声明而不是定义.</p>
<p>请看<a href="http://c.biancheng.net/cpp/html/3241.html">函数的声明</a>和<a href="https://www.runoob.com/cplusplus/cpp-variable-types.html">变量的声明</a></p>
<p>(注意一个细节, 除了函数原型以外, 声明必须给我都加extern, 因为比如<code>int a;</code>这种语句, 即可以认为是定义而没有初始化, 也可以认为是”省略了extern的变量声明”, 这点细节很容易产生歧义, 请注意!)</p>
<p>这句话讲的很好, “所谓声明（Declaration），就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。”</p>
<p>连编译器都需要定心丸, 又何况人呢?</p>
<h2 id="局部变量的”隐藏”功能"><a href="#局部变量的”隐藏”功能" class="headerlink" title="局部变量的”隐藏”功能"></a>局部变量的”隐藏”功能</h2><p>引用<a href="https://www.runoob.com/cplusplus/cpp-variable-scope.html">迷途羔羊</a>的话,”当变量间出现重名的情况下，作用域小的屏蔽作用域大的”, 说不好听就是强龙难压地头蛇, 但我觉得也可以理解为全局变量比较通情达理, 给短命的局部变量一个舞台, 不多提</p>
<h2 id="“临时变量”-是什么"><a href="#“临时变量”-是什么" class="headerlink" title="“临时变量” 是什么"></a>“临时变量” 是什么</h2><p>其实《C++ Primer第五版》并没有提到”临时变量”, 我个人愿意把”临时变量”分到pp184中”局部对象”的”自动对象”一类. 其实按照”作用域就是大括号+小括号中的代码块”这种粗暴的理解方式的话, 那么”临时变量”就是一些”小块”(比如loops中)的局部变量, 但有人觉得一定是函数中的变量才叫局部变量, 这个就仁者见仁了, 都差不多.</p>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>当前时间(2019年9月18日18:08:27), 明天写, 手指快打断了.</p>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp_刷新缓冲区demo</title>
    <url>/23454/</url>
    <content><![CDATA[<p>本文不讨论buffer的功能, 单单演示buffer刷新的场景</p>
<ul>
<li><p>思路:</p>
<ul>
<li>cout和clog不刷缓冲区, endl与cerr一定会刷缓冲区(endl=\n+flush, \n只有在行缓冲情况下会flush)</li>
<li>缓冲区和流需要用setvbuf()绑定, reasons尚不明</li>
<li>缓冲区和流绑定后, 通过观察控制台输出的停顿, 模拟缓冲区行为, 得到缓冲区的直观概念</li>
</ul>
</li>
<li><p>cout不刷新缓冲区:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">10</span>);  </span><br><span class="line">    <span class="comment">//os指定为stdout,设置控制台输出为行缓存模式(L)，把缓冲区与流相关, 缓存区大小设为10字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i; <span class="comment">// 这里可以顺便设计一个重定向, 不必老盯着控制台</span></span><br><span class="line">        Sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">//行缓冲, 遇到\n就刷新buffer[把缓存中的东西取出, 放到终端设备中]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>endl刷新缓冲区</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOFBF, <span class="number">1024</span>);  <span class="comment">//设置控制台输出为全缓存模式(F)，把缓冲区与流相关</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我会和最后一个cout一起出现\n&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我会和最后一个cout一起出现\n&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是最后一个cout, 我们三个同时出现&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----新一轮----&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我不会独自最先出现的&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;我是红色字, 我不会等, 还会连同前面cout一起刷出来\n&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有endl我就不等后面的cout了&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有endl, 前面的cout会先输出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结<ul>
<li>cout是一个os对象, 其实仅仅完成”放入缓冲区”这一功能, 要显示在显示器上还需要刷新缓冲区</li>
<li>如果只有cout没有endl, 之所以会有输出是因为return 0;后会自动执行刷新, 不刷就根本不能显示</li>
<li>把缓冲区当做一个”武器匣子”<ul>
<li>武器匣子执行”弹出”功能, 即弹出的武器是要拿来用的, 同时弹出的武器同时也从武器匣子中消除;</li>
<li>武器匣子可能会塞不下, 此时自然有两种FIFO或FILO, 联系到ring buffer以及 stack buffer</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>Fix: Can’t Right Click on Windows 10’s Taskbar Icons</title>
    <url>/333/</url>
    <content><![CDATA[<p>[不能右键点击任务栏的workaround或fix-建议使用Method2](Fix: Can’t Right Click on Windows 10’s Taskbar Icons)</p>
]]></content>
  </entry>
  <entry>
    <title>Haskell入门-知识杂记</title>
    <url>/6355/</url>
    <content><![CDATA[<p>初窥门径, 长期更新</p>
<h2 id="GHC"><a href="#GHC" class="headerlink" title="GHC"></a>GHC</h2><ul>
<li>GHC=ghc(编译器)+ghci(i=interactive, 交互式)+runghc(解释器, 不需要编译)</li>
</ul>
<h2 id="ghci"><a href="#ghci" class="headerlink" title="ghci"></a>ghci</h2><ul>
<li>i=interactive, 交互式</li>
<li>类似于python的IDLE, 同时也都有调试功能.</li>
<li>交互式Shell都有调试功能吗?</li>
</ul>
<h3 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h3><ul>
<li>Prelude是一个常用模块, 这里<code>Prelude&gt;</code> 表示预加载了Prelude模块</li>
<li>加载其他模块:<ul>
<li>指令: <code>:module 模块名&#123;例如, Data.Ratio&#125;</code>或者<code>:m 模块名&#123;例如, Data.Ratio&#125;</code></li>
<li>prompt增长: <code>Prelude&gt;</code> -&gt; <code>Prelude Data.Ratio&gt;</code></li>
</ul>
</li>
<li>Prelude提示符的替代:<ul>
<li>指令: <code>:set prompt &quot;ghci&gt;&quot;</code></li>
<li>可以乱写: <code>:set prompt &quot;sangaizhonggai&gt;&quot;</code></li>
<li>静态效果: 改完后导入模块不显示导入名.</li>
<li>重置指令: <code>:unset prompt</code></li>
</ul>
</li>
<li>建议:<ul>
<li>prompt增长起到了提示功能, 我认为有利</li>
<li>(除非左边太长)不建议瞎改成其他名字, 没什么意义</li>
</ul>
</li>
</ul>
<h3 id="ghci运算符"><a href="#ghci运算符" class="headerlink" title="ghci运算符"></a>ghci运算符</h3><ul>
<li>Haskell除法默认不floor, 不截断<ul>
<li>例子: 7/2=3.5</li>
</ul>
</li>
<li>数学上,二元运算符(binary operator)可摆放在运算数(operand)的不同位置, 分成3类:<ul>
<li>前缀运算符, 中缀运算符, 后缀运算符(自然对应3种表达式, 不多提)</li>
<li>这些”缀”只适用于二元运算符, 其他{1元}或{3元及以上}都不行</li>
</ul>
</li>
<li>Haskell不支持后缀表达式, 比如<code>5!</code>这种就没有.</li>
<li>Haskell下前中缀转换:<ul>
<li>前缀(prefix)转中缀(infix): 用”`”包起来</li>
<li>中缀(infix)转前缀(prefix): 用小括号包起来</li>
</ul>
</li>
<li>Hasekll不等号是”/=”(正斜杠+等号)而不是”!=”<ul>
<li>(想起之前有人问什么是正反斜杠: 斜率k&gt;0是正斜杠, k&lt;0是反斜杠^_^)</li>
</ul>
</li>
<li>Haskell运算符一览表<ul>
<li>初中数学老师: “表的好处有啥子呦↘一目↗了然↘一遍↗就记住~忘了↗就查↘”</li>
<li><a href="https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/haskell-operators.pdf">Haskell运算符一览表</a></li>
</ul>
</li>
<li>注意事项<ul>
<li>Haskell没有赋值行为, “-“是唯一的一元运算符, 表示”将减号作用于operand”</li>
<li>能写括号就不要懒, 不多提</li>
</ul>
</li>
</ul>
<h2 id="2019年9月6日23-00-45-待解决问题"><a href="#2019年9月6日23-00-45-待解决问题" class="headerlink" title="(2019年9月6日23:00:45) 待解决问题:"></a>(2019年9月6日23:00:45) 待解决问题:</h2><ul>
<li><del>Haskell运算符的{结合律}{优先级}{函数功能}, 有没有一个专门的cheatSheet能写清楚的?</del><ul>
<li>解决办法1:<ul>
<li>ghci键入<code>:info operator_name</code>或<code>:i operator_name</code>, 最下面infixl或者infixr, 带一个优先级数字<ul>
<li>infixl or infixr 表示”左结合”或者”右结合”</li>
<li>infix后面的数字优先级: 9&gt;8&gt;7&gt;6…&gt;1</li>
</ul>
</li>
</ul>
</li>
<li>解决办法2:<ul>
<li>概括:<a href="https://www.haskell.org/onlinereport/exps.html">Haskell-98Report-exps</a></li>
<li>查表:<a href="https://www.haskell.org/onlinereport/decls.html#fixity">Haskell-98Report-infixity</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2019年9月6日23-04-35-待整理资料"><a href="#2019年9月6日23-04-35-待整理资料" class="headerlink" title="(2019年9月6日23:04:35) 待整理资料:"></a>(2019年9月6日23:04:35) 待整理资料:</h2><ul>
<li>除却运算符一览表, 目前还收集到两份CheatSheets:<ul>
<li><a href="https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/haskell-ucs-CheatSheet.pdf">UCS-cheatSheet</a></li>
<li><a href="https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/HaskellHackageCheatSheet.pdf">Hackage-cheatSheet</a></li>
</ul>
</li>
</ul>
<h2 id="2019年9月7日13-42-33-找到”ghci缩写命令”-表"><a href="#2019年9月7日13-42-33-找到”ghci缩写命令”-表" class="headerlink" title="(2019年9月7日13:42:33) 找到”ghci缩写命令” 表:"></a>(2019年9月7日13:42:33) 找到”ghci缩写命令” 表:</h2><ul>
<li>原网页:<a href="https://github.com/ghc/ghc/blob/e3ec2e7ae94524ebd111963faf34b84d942265b4/ghc/GHCi/UI.hs#L160">ghc-commands</a></li>
<li>用法指导:<a href="https://stackoverflow.com/questions/47265489/is-there-a-list-of-ghci-abbreviated-commands">so :c means :cd, :d means :def, follow the order.</a></li>
<li>缩写命令表:<a href="https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/ghci-abbreviated-commands.pdf">这里</a></li>
</ul>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><ul>
<li>阶级性: <ul>
<li>内容: 函数, 变量必须用小写字母开头; 类型必须用大写字母开头.</li>
<li>好处: 便于分辨函数与类型.</li>
</ul>
</li>
<li>在ghci中let定义临时变量:<ul>
<li>ghci&gt; <code>let e = exp 1</code></li>
<li>注意let用法在ghci和haskell script存在不同, 尽量不要用let定义</li>
<li><del>(2019年9月7日15:20:27) 待补充: 常规形式的变量定义是?</del><ul>
<li>就是<code>x=5</code>这种</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2019年9月11日19-39-32-Haskell参考资料已汇总"><a href="#2019年9月11日19-39-32-Haskell参考资料已汇总" class="headerlink" title="(2019年9月11日19:39:32) Haskell参考资料已汇总"></a>(2019年9月11日19:39:32) Haskell参考资料已汇总</h2><ul>
<li>此后只需记录一些不很重要的细节即可</li>
<li><img src="/6355/Haskell-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE.jpg" class="" title="Haskell部分书签">

</li>
</ul>
<h2 id="ASCII字符码"><a href="#ASCII字符码" class="headerlink" title="ASCII字符码"></a>ASCII字符码</h2><ul>
<li>举例, ‘\100’ 表示ASCII=100的那个字符, 即: ‘\100’ -&gt; ‘d’<br>  <code> ghci&gt;:t &#39;\100&#39;</code><br>  <code> &#39;\100&#39; :: Char</code></li>
<li>‘&#39;转义功能和其他语言一致, 所以:<br>  <code> ghci&gt; putStrLn &#39;\\&#39;</code><br>  <code> \</code></li>
</ul>
<h2 id="2019年9月11日19-57-54-Haskell风格补充"><a href="#2019年9月11日19-57-54-Haskell风格补充" class="headerlink" title="(2019年9月11日19:57:54) Haskell风格补充"></a>(2019年9月11日19:57:54) Haskell风格补充</h2><ul>
<li>注意, Haskell风格除了”类型大写, 函数与变量小写”之外, 还有”尽可能采用驼峰命名”这一条</li>
</ul>
<h2 id="What-is-‘xs’"><a href="#What-is-‘xs’" class="headerlink" title="What is ‘xs’?"></a>What is ‘xs’?</h2><ul>
<li>You might wonder where the variable name xs comes from in the Haskell function. This is a common naming pattern for lists: you can read the s as a suffix, so the name is essentially “plural of x”. 10 comments</li>
<li><a href="http://book.realworldhaskell.org/read/types-and-functions.html#x_iB1">这里</a></li>
</ul>
<h2 id="Type-variable-gt-Good-naming"><a href="#Type-variable-gt-Good-naming" class="headerlink" title="Type variable -&gt; Good naming."></a>Type variable -&gt; Good naming.</h2><ul>
<li>小写开头就行了: Type variables can have any names with lowercase alphas.</li>
<li>例子:<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Num</span> num =&gt; num -&gt; num</span><br><span class="line"><span class="title">f</span> x  = <span class="number">4</span>*x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span>()</span><br><span class="line"><span class="title">main</span> = print $ f <span class="number">5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>入门向</tag>
        <tag>碎片信息集散</tag>
        <tag>长期更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell目前存在的问题</title>
    <url>/23067/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>在Win平台下找不到一款较好的IDE进行使用, 虽然Haskell一般也打不了多少字, 但是还是希望能够有IDE</li>
<li>函数类型签名及类型类的使用仍处于基本懵B状态, 只会观察报错信息来不断事后补充签名, 函数类型的确认也不很熟练, 在pp107_findIndices实现时不知道必须使用[Int]作为返回值类型, 其原因现在仍未搞清楚.</li>
<li>起步不到一个月, 像Monad和Just这种抽象知识欠缺过多.</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>今天尝试配一下Win emacs, 据群上说这个比较好用, 要达到:<ul>
<li>智能提示</li>
<li>自动补全</li>
<li>不需创建工程</li>
</ul>
</li>
<li>我们的目标暂时还不在这个类型系统上, 于是先放一放这个签名(毕竟就算不签名强大的Haskell类型推断系统也会帮你推出来的, 推不出来报错你也可以看得懂), 菜鸡还是要有菜鸡的自觉性好一些, 我先随缘签名了.</li>
<li>已经购买了TTPL和PLDS, 这个看完之后估计对Monad的认识就可以比较深入了, 书也不算厚.</li>
</ol>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell类型类专题1</title>
    <url>/18741/</url>
    <content><![CDATA[<p>Haskell类型类既不是”类型”, 也不是”类型的类型”, 此处中文的”类型类”与英文的”Typeclass”都很confusing, 以下整理一些常见的问题及其解答(FAQ):{以下理解都非常粗浅, 因为我学这个不到2星期}</p>
<h2 id="类型类究竟是什么-和类型有什么联系"><a href="#类型类究竟是什么-和类型有什么联系" class="headerlink" title="类型类究竟是什么? 和类型有什么联系?"></a>类型类究竟是什么? 和类型有什么联系?</h2><ul>
<li>类型类与接口相似, 是类型的标杆.”入乡随俗”<ul>
<li>显示了类型的一些属性</li>
<li>赋予了类型一些功能</li>
<li>限制了类型的一些行为</li>
<li>不限死某种特定的”类型”</li>
</ul>
</li>
<li>虽然类型类与接口相似, 但是类型类本身可以完成缺省的函数实现, 也可以多继承, 给类型定义带来福利.<ul>
<li>给既有类型的福利:<ul>
<li>(这点存疑, 不确定)因为可以完成缺省函数实现(也就是Haskell内部已经定义而非仅仅声明), 所以这个抽象的”接口”实际上可以变成实际的”汽油机”, 也即我们不需要对接口进行自定义的Implement, 可以直接使用Haskell自身定义好的类型类.</li>
</ul>
</li>
<li>给新类型的福利:<ul>
<li>因为可以多继承, 所以newtype时候就可以直接detriving, 省下很多(像什么友元声明,单例继承一堆破事)的代码.</li>
</ul>
</li>
</ul>
</li>
<li>类似于C++的模板, 可以默认也可以特化.请看<a href="https://www.zhihu.com/question/41270359/answer/90337677">这里</a></li>
</ul>
<h2 id="类型类能用来干什么"><a href="#类型类能用来干什么" class="headerlink" title="类型类能用来干什么?"></a>类型类能用来干什么?</h2><ul>
<li>给予某个新类型一些函数(或者算子,都一样), 例如<a href="https://rwh.readthedocs.io/en/latest/chp/6.html#the-need-for-typeclasses">这里</a>定义的Color类型.<ul>
<li>因为Color是新定义类型(且字面值中没有数字或字符串这些东西,所以)没法被Haskell”类型推断机制”识别, 所以默认是不给Color任何类型类的, 那么”判断相等或不等”这件事就需要自己写函数, 3个颜色9种组合, 只有{RR}{GG}{BB}3种正确, 所以给出相等的定义.<ul>
<li>这种操作是低效的,按照C++观点就是没有对”相等”这件事进行重载, 事实上这个思想是共通的, 只是Haskell是用类型类来把”重载”这件事也给提取并抽象为类型类了</li>
<li>为什么不能不重载? 不重载的坏处是:<ul>
<li>假设我们是一个宠物专卖店, 有100种狗, 并且由于生理因素的划分必须每种狗都建立一种类型, 那么所有的判断”(狗的种类)是否相等”的函数就会有100种(类似”京巴狗_Eq”, “拉布拉多犬_Eq”, “金毛败犬_Eq”…)</li>
</ul>
</li>
<li>如果我的”相等”判定比较特殊(奇葩), 我判定的标准是: 例如{“拉布拉多犬”, “拉布拉多狗”, “拉布拉多”}三个字符串是可以认为他们”相等”的, 那这种情况要怎么处理?<ul>
<li>如果在C++中:<ul>
<li>在重载算子的时候请谨慎一点(推荐尽量不要重载算子)因为你到时候这个”=”一旦被继承, 根本不知道bug出在”犬”和”狗”的身上.</li>
</ul>
</li>
<li>如果在Haskell中, <ul>
<li>推荐单独写函数, 因为重载的算子实际上就是一种函数, 并且函数全局下只有一种定义(?存疑, 这点待求证), 我不确定会不会重载掉”=”之后全局的等号都会被污染.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>粗浅理解就是:<ul>
<li>引入算子:<ul>
<li>如果实现类型时要用到”=”, 那么请引入”Eq”类型类.</li>
</ul>
</li>
<li>注意类型类之间的依赖:<ul>
<li>如果要实现”&gt;”,”≥”, 那么请引入”Ord”的同时, 引入”Eq”, 因为”Ord”依赖着”Eq”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对某些”类型划分不单一”的字面量进行合理限制, 例子见《Haskell函数式编程入门-第二版-第一卷》51-52页<ul>
<li>举例: <code>:type 5</code> -&gt; <code>5 :: Num a =&gt; a</code></li>
<li>首先, 字面量分两种, 一种是具有明确类型的,一类是不具有明确类型的.<ul>
<li>具有单一类型的字面量:<ul>
<li>{‘a’, ‘b’, ‘c’}, 一定是Char类型</li>
<li>{True, False}, 一定是Bool类型</li>
</ul>
</li>
<li>类型划分不单一的字面量:<ul>
<li>数字5: 只能说一定得满足Num类型类要求, 但具体是哪种类型不确定.(视情况, 既可以是Int{8,16,32,64}, 也可以是Integer, 也可以是Int, 也可以是Float or Double)</li>
<li>字符列表”abc”: 只能说一定得满足<code>[Char]</code>类型类要求, 但具体是哪种类型不确定.(既可以是”字符串”也可以是”字节串”(ByteString))<ul>
<li>(和python2类似的老毛病) </li>
<li>(当然这个在C++和python3里面已经可以通过开头加一个b解决了)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了对这些字面量进行约束, 给字面量施加类型类约束, 这样字面值5既可以在各种场合以各种类型出现(而不需要类型转换), 又使得字面量得到了一定的限制, 例如5+”abc”会报错这样.</li>
<li>顺带一提, 因为5的类型划分不单一, 所以一些Haskell专家(见《Haskell函数式编程入门-第二版-第一卷》51-52页)直接把数字字面量视作”重载了的字面值”(overloaded literals)<ul>
<li>类似重载的行为: <ul>
<li>5作为一个”数字字面量”, 具有很多种类型, 相当于5在不同场合下自动进行了”类型重载”, 因此我们称5为”可重载的字面值”, 抑或”重载了的字面值”, 举例, 字面值5自身就可以作为Int和Integer两种类型, 不同场合就像被”自动化地重载”了一样</li>
</ul>
</li>
<li>类型类Num是从”类型集合”中提取出来的:<ul>
<li>虽然5没有确定的类型, 或者说5存在一个可供特定场合挑选的”(很多)类型(的)集合”, (集合长度&gt;=3), 但是这个集合中的每一个”类型”, 不管你是Int还是Float还是Integer, 都必须给我实现Num类型类接口, 因为这个集合中所有的元素(也即5可以挑选的所有的”类型”)都必须实现Num类型类接口, 所以5就因此必须实现Num类型类接口.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="目前存在的疑问"><a href="#目前存在的疑问" class="headerlink" title="目前存在的疑问"></a>目前存在的疑问</h2><ul>
<li><p>定义函数时, 限定语句<code>f :: Num a =&gt; a -&gt; a</code>存在的意义是”双重保险”吗? 能不能删除?</p>
<ul>
<li>在不严谨的场合下, 是否可以省略?<ul>
<li>例子, 我自己写斐波那契函数没写这行, runghc也不报错</li>
</ul>
</li>
<li>在严谨的场合下, 到底要多严谨?<ul>
<li>因为”Haskell类型推断系统”肯定很厉害, 那么他应该会帮我检查出类型的错误才对, 那么我再写一遍这个”限定语句”有两种情况:<ol>
<li>我菜, 比推断系统想得少, 没有很好地限制死函数类型, 导致多态应用出错, 而如果我装傻不写, 这个错误就会在编译时被检查出来(存疑?不知道是不是编译时检查?), 怎样才是好的做法?</li>
<li>我自作聪明, (在特定需求下定制参数类型)比推断系统想得多, 但是如果限制得比较死(比如RGB参数限制在Word8这种比较小的区间下, 这个倒是Best Pratice, 我举不出那种”取值区间本没必要限制得那么死”例子, 反正就是这个意思),据说<a href="https://www.douban.com/group/topic/23342792/#291372451">编译器特定优化后效率可得到提升</a>, 这样要是以后需要”泛化版本”会不会带来麻烦?<ul>
<li>我不知道这个”范围限制”到底是我的责任还是Haskell推断系统的责任?</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>既然声明类型变量(type-variables)时可以随意选用字母, 为什么在这里没有出一套naming conventions这样的限制来约束代码, 增强函数的可读性?</p>
</li>
</ul>
<h2 id="参考网站-amp-参考书"><a href="#参考网站-amp-参考书" class="headerlink" title="参考网站 &amp; 参考书"></a>参考网站 &amp; 参考书</h2><ul>
<li><a href="https://www.douban.com/group/topic/23342792">Haskell新手FAQ</a></li>
<li><a href="https://rwh.readthedocs.io/en/latest/chp/6.html">Real world Haskell-类型类</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/haskell-guide/build-our-own-type-and-typeclass.html">构造我们自己的 Types 和 Typeclasses</a></li>
<li>《Haskell函数式编程入门-第二版-第一卷》</li>
</ul>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>类型类</tag>
      </tags>
  </entry>
  <entry>
    <title>clion单项目多个cpp文件设置</title>
    <url>/59330/</url>
    <content><![CDATA[<ul>
<li>所需的文档结构是:<ol>
<li>单个CppSnippets项目下, 多个cpp文件, </li>
<li>每一个cpp文件中各有一个main函数并保持独立执行</li>
</ol>
</li>
<li>条件是:<ol>
<li>clion插件, 网址: <a href="https://plugins.jetbrains.com/plugin/8352-c-c--single-file-execution">clion独立执行单个cpp文件插件</a></li>
<li>大项目下, 每个cpp文件不得以main.cpp命名, 由于独立执行,每个cpp文件都必须有main函数</li>
<li>在每个cpp文件中右键”Add executable for single file”, 此时右下角会有弹窗</li>
<li>查看CMakeLists文件, 多了一行add_executable(filename filename.cpp)即证明build已成功</li>
<li>左上角下拉框, 选择对应文件运行:<img src="/images/clion%E5%8D%95%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%A0%B7%E4%BE%8B.jpg" alt="clion左上角下拉框"></li>
</ol>
</li>
<li>尚未解决的问题:<ul>
<li>无法使用中文进行文件命名, 用中文命名则无法reload</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>clion</tag>
      </tags>
  </entry>
  <entry>
    <title>win下Clion命令行乱码问题</title>
    <url>/37631/</url>
    <content><![CDATA[<p>settings设置如图:<br><img src="/images/clion%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%A0%B7%E4%BE%8B.jpg" alt="settings设置样例"><br>default settings也顺便设置一下比较好</p>
<ul>
<li>要点:<ul>
<li>只有path设置为gbk</li>
<li>更改为gbk时有两个选项”Reload”和”Convert”, 选择”Convert”</li>
<li>设置gbk的另一个办法是直接在文件上右键点击file encoding选择gbk</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>clion</tag>
      </tags>
  </entry>
  <entry>
    <title>git bash下windows-style路径转换</title>
    <url>/42399/</url>
    <content><![CDATA[<ul>
<li><p>缘起:</p>
<ul>
<li>在windows平台下,由教程<a href="https://xbeta.info/win-run.htm">善用佳软winr</a>, 我们知道可以利用winr唤醒gitbash(我记为gb), 但是进入gitbash后当前目录往往并不是工作目录, 需要cd几轮进行跳转,这件事很烦人.</li>
</ul>
</li>
<li><p>思路</p>
<ul>
<li>由listary的”路径复制”功能, 可以迅速获得某个文件的地址(或者其所在文件夹) 举例:<ul>
<li><img src="/42399/listary%E5%A4%8D%E5%88%B6%E8%B7%AF%E5%BE%84%E8%87%B3%E5%89%AA%E8%B4%B4%E6%9D%BF.jpg" class="" title="listary复制路径至剪贴板-如图红色框框"></li>
<li>这个路径显然是windows-style的路径, 但是我们需要的是unix like的路径才能直接在git bash里面cd {some unix-like path}这样子</li>
</ul>
</li>
<li>既然我们可以轻松地复制得到一个 windows-like的路径, 类似这样:{D:\备份地点\文档资料备份地点\cmBooks\Cpp\风浦可符香.jpg}, 那么有没有一个path conversion, 能够接受windows-path, 然后返回Unix-path的呢?</li>
<li>倘若有,windows-path我们先convert成为unix-path, 然后直接把unix-path传给cd就可以了</li>
</ul>
</li>
<li><p>资料 &amp; 分析</p>
<ul>
<li>stackOverflow上找到<a href="https://stackoverflow.com/questions/13701218/windows-path-to-posix-path-conversion-in-bash">Windows PATH to posix path conversion in bash</a></li>
<li>csdn上找到<a href="https://blog.csdn.net/zwt0909/article/details/52813388">shell命令结果赋值给变量</a></li>
<li>很明显, 只要用wp(windows-path)和up(unix-path)两个变量即可达成.</li>
</ul>
</li>
<li><p>举例分析</p>
<ul>
<li>要访问这个文件夹:{D:\备份地点\文档资料备份地点\cmBooks\Cpp}</li>
<li>首先listary获取路径(过于简单,省略), 此时路径已经在我们的剪贴板中了</li>
<li>git bash下<ul>
<li>wp=’D:\备份地点\文档资料备份地点\cmBooks\Cpp’</li>
<li>up=$(echo “/$wp” | sed -e ‘s/\///g’ -e ‘s/://‘)<ul>
<li>注意这个$wp前面的backslash不能省略!</li>
</ul>
</li>
<li>cd $up, 大功告成</li>
</ul>
</li>
<li>一图胜千言:<ul>
<li><img src="/42399/%E8%B7%AF%E5%BE%84%E8%BD%AC%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" class="" title="wp是windows-path; up是unix-path">
</li>
</ul>
</li>
</ul>
</li>
<li><p>反思</p>
<ul>
<li>能不能利用alias或者自定义函数对这个进行直接调用呢?</li>
</ul>
</li>
<li><p>感想</p>
<ul>
<li>很久以前我在github的git-for-windows下面问了一圈,没人鸟我,这个如此简单的痛点竟然没人解决,妈的.</li>
<li>每天我都要一遍遍告诉自己不是一个天才, 真累啊~</li>
</ul>
</li>
<li><p>参考信息截图(不po了, 就是一个记录而已)已存储</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>git-bash</tag>
        <tag>windows-unix路径转换</tag>
      </tags>
  </entry>
  <entry>
    <title>git-bash路径转换函数化</title>
    <url>/39008/</url>
    <content><![CDATA[<ul>
<li><p>流程:</p>
<ul>
<li>文档<a href="https://coderwall.com/p/_-ypzq/git-bash-fixing-it-with-alias-and-functions">Git Bash - Fixing it with alias and Functions</a>告诉我们可以实现在bashrc下写函数,这些函数可以在git bash下调用</li>
<li>菜鸟教程<a href="https://www.runoob.com/linux/linux-shell-func.html">shell函数</a>告诉我们怎么写bash函数</li>
<li>shell有个只能ret整数的坑[shell-only-ret-ints], 想要ret字符串还是需要利用”$(func params)”外部捕获,参考<a href="https://blog.csdn.net/zycamym/article/details/45191093">shell函数返回字符串</a></li>
</ul>
</li>
<li><p>图示</p>
<ul>
<li><img src="/39008/w2u%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0.jpg" class="" title="windows-path to unix-path 转换函数"></li>
<li><img src="/39008/w2u%E7%94%A8%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" class="" title="w2u函数用法示意图">
</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>勤用alias(常用的cd命令什么的建议全部装进去), 真的好用, 我已经用疯了(^_^)</li>
</ul>
</li>
<li><p>感想</p>
<ul>
<li>人们常说的肉食者鄙, 事实上有一定道理, 我不信一群权威的bash专家, 会没有想到我这个bash小白都能想出来并搞定的问题</li>
<li>香港动乱,历史或将继续增添些许无辜者的鲜血,这种日常一脉相承了上下五千年, 全部被预言中了呀,黑格尔这个糟老头子真是坏得很!</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>windows-unix路径转换</tag>
        <tag>git bash</tag>
      </tags>
  </entry>
  <entry>
    <title>github备份hexo博客原始数据</title>
    <url>/1876/</url>
    <content><![CDATA[<ul>
<li><p>缘起:</p>
<ul>
<li>尽管hexo已交给github pages进行托管, 上传到github却仅仅是编译后的html文件, 不是有效备份</li>
<li>我们要备份博客的md文件, themes文件等等原数据, 以便将来更换电脑时的交接</li>
</ul>
</li>
<li><p>思路:</p>
<ol>
<li>所有博客数据分为两类, 一类是原始数据(md文件, 不同用途的_config.yml文件), 一类是编译后的数据(css等等乱七八糟的文件)<ul>
<li>原始数据: <img src="/images/hexo%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE-%E5%B9%B2%E5%87%80%E6%95%B0%E6%8D%AE.jpg" alt="hexo原始数据"> </li>
<li>编译后数据: <img src="/images/hexo%E7%BC%96%E8%AF%91%E6%95%B0%E6%8D%AE-%E8%84%8F%E6%95%B0%E6%8D%AE.jpg" alt="hexo垃圾数据"></li>
</ul>
</li>
<li>仅仅关心原始数据的存储安全, 我们也只做原始数据的手动管理, 编译后数据我们不关心</li>
<li>建立hexo和master两个分支, hexo装着原始数据, master装着编译后的脏数据, 以此区分</li>
<li>git push永远针对原始数据的上载和下载, 于是将hexo作为默认分支</li>
</ol>
</li>
<li><p>过程:</p>
<ul>
<li><p>hexo分支创建:(如果第一次备份原始数据: 此时你的github应只有一个master分支, 并且master分支像上述那个2019的图一样)</p>
<ol>
<li>新建hexo分支, hexo设为默认分支</li>
<li>git clone到Linkeer365Blog文件夹下, <ul>
<li>此时应该是”Blog/Linkeer365.github.io”</li>
<li>因为hexo是默认分支, 所以git clone的就是hexo分支</li>
</ul>
</li>
<li>把github.io文件夹删除到只剩一个.git</li>
<li>把原始数据(除了deploy_git以外全部文件)放到github.io文件夹中<ul>
<li>要确保”原始数据”这些文件夹里面没有.git文件, 防止git嵌套上传出错</li>
</ul>
</li>
<li>对github.io文件夹git add, git commit, git push, 检查hexo分支是否一如预期</li>
</ol>
</li>
<li><p>hexo备份数据下载: (如果你是在新电脑上工作: 此时你应该已有hexo分支, 但是新电脑还有配置上的问题)</p>
<ol>
<li>完成配置git密钥,nodejs, hexo等等, 估计要再查一遍教程</li>
<li>新建 Linkeer365Blog, 此时直接git clone, 不需要也不可以hexo init初始化(因为你已经有现成的文件夹和文件了, hexo init会造成_config.yml文件重置)</li>
<li>在github.io文件夹下, npm install / npm install hexo-deployer-git –save / hexo g -d(最后一个一键生成并部署, 也可以拆开)</li>
<li>接到上段第5点的种种git操作</li>
</ol>
</li>
<li><p><del>git commit托管: 一键上传原始数据</del> 老老实实一步步git add; git commit这样来</p>
<ul>
<li>没有git add会忽略新建的文件的上传!</li>
<li>防止同时编辑的冲突: git pull<ul>
<li>看看有没有人正在编辑这个文件</li>
<li>当然一个人就不用啦</li>
</ul>
</li>
<li>全部修改一键上传: git commit -a; git push</li>
<li>全部修改一键上传带注释: git commit -am “2019\8\4\02:38:30”; git push</li>
</ul>
</li>
<li><p>hexo 托管: 一键发博客</p>
<ul>
<li>发送博客并部署博客: hexo g -d</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>留意点<ul>
<li>替身意识: 每次操作文件数据都要先做一个简单备份</li>
<li>每次提交时, 请先进行git commit 操作, 再进行hexo 操作</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>自动保存</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo上传图片-独立文件夹模式</title>
    <url>/1904/</url>
    <content><![CDATA[<ul>
<li><p>问题</p>
<ul>
<li>前日博客所写的图片上传法, 将图片一股脑儿塞在同一文件夹images下面, 图片一多显然混乱</li>
</ul>
</li>
<li><p>思路</p>
<ul>
<li>独立文件夹模式: 一个md文件对应一个同名的文件夹, md文件所引用的图片将全部置于该同名文件夹下.</li>
</ul>
</li>
<li><p>条件:</p>
<ul>
<li>将_config.yml文件(改文件与source文件夹同级)中的post_asset_folder项设为true, 此时执行hexo new filename 就会同时生成filename.md和filename文件夹:<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">hexo相对路径插入图片</a></li>
<li>windows下git bash也是可以使用alias进行命令简化的:<a href="https://blog.csdn.net/weixin_34319999/article/details/87240581">win下gitbash的alias教程</a></li>
<li>hexo标签插件语法:<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">% asset_img (这是图片名)风浦可符香.jpg (这是图片描述)可爱的赤木杏 %</a></li>
</ul>
</li>
<li><p>流程:</p>
<ul>
<li>改好config文件并设好alias之后, 我们直接生成现在这个md文件以及对应文件夹.</li>
<li>将图片放进文件夹内</li>
<li>使用标签插件语法, 如下:<ul>
<li><img src="/1904/%E9%A3%8E%E6%B5%A6%E5%8F%AF%E7%AC%A6%E9%A6%99.jpg" class="" title="可爱的赤木杏"></li>
<li>asset_img不是指文件夹名字, 就叫asset_img, 改动的只有文件名和文件描述.</li>
</ul>
</li>
</ul>
</li>
<li><p>成果:</p>
<ul>
<li>从当下时间2019年8月13日16:04:45起, 每次写md文件, 图片都会放在对应的同名文件夹下, 便于管理.(之前的图片就不一一更改了)</li>
<li>图片多了一个”comments”的fields我觉得很好, 并且首页和归档都能清晰显示</li>
</ul>
</li>
<li><p>反思</p>
<ul>
<li>对未来事态的遇见是相当重要的, 不能空凭着好运气.</li>
<li>风浦同学, 一起去摩挲达树海吧, 我对爱对世界这样的词语早就力不从心了! (^_^)</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>上传特定类型文件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文中插图教程</title>
    <url>/43755/</url>
    <content><![CDATA[<ul>
<li><p>要求是:</p>
<ul>
<li>文章中必须能显示(ok)</li>
<li>首页最好可以显示(ok)</li>
</ul>
</li>
<li><p>方法:</p>
<ol>
<li>source文件夹下新建images文件夹, 把所有图片放在此处<ul>
<li>日后图片多了, 可能要多设一个子文件夹, 道理一样</li>
<li><img src="/images/%E6%8A%8A%E5%9B%BE%E7%89%87%E6%94%BE%E5%9C%A8images%E7%9B%AE%E5%BD%95%E4%B8%8B.jpg" alt="把图片放入images文件夹下"></li>
</ul>
</li>
<li>markdown语法采用绝对路径<ul>
<li>问题:能不能使用win风格的路径(例如D:/images/图片3.jpg)呢?</li>
<li><img src="/images/%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E6%A0%B7%E5%BC%8F.jpg" alt="绝对路径的引用语法"></li>
</ul>
</li>
</ol>
</li>
<li><p>参考网站:</p>
<ul>
<li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">hexo文中插图的参考网站</a></li>
<li>此处采用了他的第一个办法, 隐患是不知道图片多了会有什么弊端.</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>上传特定类型文件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置分享</title>
    <url>/46352/</url>
    <content><![CDATA[<p>分享一个不错的hexo教程, 思路很清晰, 看了他的我的就不用看啦(^_^)<br><a href="https://xiaotiandi.github.io/publicBlog/2018-09-19-dab4328f.html">小天地-hexo插入各类文件</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea使用指南</title>
    <url>/29832/</url>
    <content><![CDATA[<p><a href="http://wuxiaolong.tech/?p=33">5分钟处理IntelliJ IDEA-2019.3.1</a></p>
]]></content>
  </entry>
  <entry>
    <title>mysql8.0以上修改密码办法</title>
    <url>/39627/</url>
    <content><![CDATA[<img src="/39627/Screenshot_20201118_193442.jpg" class="">

<p>其他修改密码的办法完全不能用，又是受苦的一小时…</p>
]]></content>
  </entry>
  <entry>
    <title>next主题站内搜索</title>
    <url>/7748/</url>
    <content><![CDATA[<p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">站内搜索</a></p>
<img src="/7748/20200329_201444.png" class="">
]]></content>
  </entry>
  <entry>
    <title>python函数装饰器</title>
    <url>/46386/</url>
    <content><![CDATA[<ul>
<li>缘起<ul>
<li>日志与函数计时功能的实现</li>
<li>学弟问起此话题,自己也感到初学时颇费功夫.</li>
</ul>
</li>
<li>背景<ul>
<li>返回同类指针: 装饰器本质只是函数or类, 唯一不同之处只在于返回值是函数指针or类指针</li>
<li>@符号: 装饰器的”@”符号没什么特别, 完全等价于(目标函数定义好后)把目标函数作为实参传进装饰器(再赋值给函数变量)<ul>
<li>装饰-赋值: bar=decorator(bar)</li>
<li>调用装饰后函数: bar()</li>
</ul>
</li>
<li>“插件”本质: 其他函数与装饰器关系独立, 装饰器执行不依赖也不影响其他函数的功能.</li>
</ul>
</li>
<li>Demo理解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 函数实体的存在是既定的, 不依赖于特定函数名.</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line">def greet(name):</span><br><span class="line">    return &#39;Nice to meet you, &#39;+name</span><br><span class="line"></span><br><span class="line">print(greet)</span><br><span class="line"># out: &lt;function greet at 0x00000259C5FAD1E0&gt;</span><br><span class="line">## 函数实体已建立, 是&lt;function greet at 0x00000259C5FAD1E0&gt;</span><br><span class="line">## 此时, greet仅仅是一个变量名, 一个函数指针, 它指向的函数对象是&lt;function greet at 0x00000259C5FAD1E0&gt;</span><br><span class="line"></span><br><span class="line">sayNiceToMeetYou&#x3D;greet</span><br><span class="line"># python默认是浅复制, 事实上sayNiceToMeetYou与greet指向同一个对象, 该对象类型是函数</span><br><span class="line"></span><br><span class="line">print(id(sayNiceToMeetYou),id(greet))</span><br><span class="line">## out: 1980378239456 1980378239456, 符合假设</span><br><span class="line"></span><br><span class="line">del greet</span><br><span class="line"></span><br><span class="line">print(sayNiceToMeetYou(&#39;lkr&#39;)) </span><br><span class="line"># out: Nice to meet you, lkr, 说明仅仅删除指针, 函数实体并没有被删除</span><br><span class="line"></span><br><span class="line">## 正戏开始</span><br><span class="line"></span><br><span class="line">def decorator(func):</span><br><span class="line">    def wrapper_who_return_funcPtr():</span><br><span class="line">        # 返回参数列表: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;snow-backup&#x2F;p&#x2F;11077917.html</span><br><span class="line">        # inspect库: https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;inspect.html</span><br><span class="line">        print(&#39;before &#123;&#125; works.&#39;.format(decorator.__code__.co_varnames[0]))</span><br><span class="line">        func()</span><br><span class="line">        print(&#39;After &#123;&#125; works.&#39;.format(decorator.__code__.co_varnames[0]))</span><br><span class="line">    return wrapper_who_return_funcPtr</span><br><span class="line"></span><br><span class="line">decorator(sayNiceToMeetYou)</span><br><span class="line"></span><br><span class="line"># d_sayNiceToMeetYou&#x3D;copy.deepcopy(sayNiceToMeetYou)</span><br><span class="line"># # print(id(sayNiceToMeetYou),id(d_sayNiceToMeetYou))</span><br><span class="line">## out: 2303771464160 2303771464160, 没有新对象生成, 难道深拷贝也出了问题吗?</span><br><span class="line">## 答案找到了: https:&#x2F;&#x2F;docs.python.org&#x2F;3.7&#x2F;library&#x2F;copy.html 搜索&quot;It does “copy” functions and classes (shallow and deeply), by returning the original object unchanged&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>后记<ul>
<li>发现了一篇深度好文<a href="https://www.zhihu.com/question/26930016/answer/99243411">刘志军</a>, 感觉我没什么必要多讲了, 被讲光了(&amp;^%^&amp;)</li>
<li>文章截图:<ul>
<li><img src="/46386/%E5%88%98%E5%BF%97%E5%86%9B-%E8%A3%85%E9%A5%B0%E5%99%A8.jpg" class="" title="注意functools.wraps的使用可以调取原函数阐释信息">




</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>python模块知识碎片</title>
    <url>/27979/</url>
    <content><![CDATA[<ul>
<li>缘起<ul>
<li>本文是对<a href="https://www.bilibili.com/video/av39465023">python核心编程 Part1</a>中的深浅拷贝内容的提炼, 非常感激热心的up主</li>
</ul>
</li>
<li>结论<ul>
<li>import搜索目录为sys.path这个列表<ul>
<li>由于是列表所以可以更改, 比如加入github.io文件夹什么的</li>
<li>sys.path的改变不跨文件, 可以拿两个py文件自己试下</li>
</ul>
</li>
<li>使用M模块中途M模块被修改, 使用imp.reload(module)进行模块的重新导入<ul>
<li>质疑: 是否本就不应该在使用某个模块的中途去修改这个模块</li>
<li>全模块导入时存在模块依赖: 如果M模块自身也import了其他模块M1,M2, 那么这些M1,M2并不会被导入: 详见<a href="https://blog.csdn.net/dashoumeixi/article/details/80819059">python全模块reload的坑</a></li>
</ul>
</li>
<li>避免循环引用<ul>
<li>循环引用: 存在a.py与b.py, 此时a.py中写import b同时b.py中写import a</li>
<li>设计观点: “类-接口”模式的重要性, 包括:<ul>
<li>类C1,C2,C3…不互相import对方</li>
<li>import工作完全由接口实现, 接口I1,I2也要做到相对独立</li>
<li><img src="/27979/python%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%88%86%E7%A6%BB%E8%AE%BE%E8%AE%A1.jpg" class="" title="设计思想: 接口与类分离实现">
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>python深浅拷贝</title>
    <url>/24464/</url>
    <content><![CDATA[<ul>
<li><p>缘起</p>
<ul>
<li>本文是对<a href="https://www.bilibili.com/video/av39465023">python核心编程 Part1</a>中的深浅拷贝内容的提炼, 非常感激热心的up主</li>
</ul>
</li>
<li><p>背景</p>
<ul>
<li>众所周知, python默认进行浅拷贝, 而深拷贝需要动用copy模块下的copy.deepcopy</li>
<li>深浅拷贝的实质区别在于是否生成了新的对象, 深拷贝生成了新的对象, 浅拷贝在同一个对象上增加了一个引用</li>
<li>不同对象可以由id进行区分</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>deepcopy作用于容器时, 深拷贝是递归进行的</li>
<li>copy.copy作用于容器时<ul>
<li>容器是可变对象, 此时copy.copy只对第一层进行深拷贝, 其余浅拷贝</li>
<li>容器是不可变对象, 此时copy.copy对容器整体进行浅拷贝</li>
</ul>
</li>
</ul>
</li>
<li><p>演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"># l for list</span><br><span class="line"></span><br><span class="line">l1,l2&#x3D;[1,2,3],[1,2,3]</span><br><span class="line">print(&#39;l1:&#123;&#125;;\tl2:&#123;&#125;&#39;.format(id(l1),id(l2))) </span><br><span class="line">l12&#x3D;[l1,l2]</span><br><span class="line"></span><br><span class="line">d_l12&#x3D;copy.deepcopy(l12)</span><br><span class="line"></span><br><span class="line">print(&#39;l12:&#123;&#125;;\td_l12:&#123;&#125;&#39;.format(id(l12),id(d_l12))) # deepcopy外壳实现了深拷贝</span><br><span class="line">print(&#39;l1:&#123;&#125;;\tl12元素0:&#123;&#125;;\td_l12元素0:&#123;&#125;&#39;.format(id(l1),id(l12[0]),id(d_l12[0]))) # deepcopy内部元素同样也实现了深拷贝:l12的元素0就是l1对象本身; 而d_l12元素0不是l1对象</span><br><span class="line"># 由于l2也是同样的情况, 所以就不演示了</span><br><span class="line"></span><br><span class="line"># cc for copy_copy obj</span><br><span class="line"></span><br><span class="line">cc_l12&#x3D;copy.copy(l12)</span><br><span class="line"></span><br><span class="line">print(&#39;l12:&#123;&#125;;\tcc_l12:&#123;&#125;&#39;.format(id(l12),id(cc_l12))) # 对l12可变对象: copy.copy外壳实现了深拷贝</span><br><span class="line">print(&#39;l1:&#123;&#125;;\tl12元素0:&#123;&#125;;\tcc_l12元素0:&#123;&#125;&#39;.format(id(l1),id(l12[0]),id(cc_l12[0]))) #  copy.copy内部元素仅仅实现了浅拷贝:l12的元素0就是l1对象本身; 而cc_l12元素0也是l1对象本身</span><br><span class="line"></span><br><span class="line"># t for tuple</span><br><span class="line">t12&#x3D;(l1,l2)</span><br><span class="line">cc_t12&#x3D;copy.copy(t12)</span><br><span class="line">print(&#39;t12:&#123;&#125;;\tcc_t12:&#123;&#125;&#39;.format(id(l12),id(cc_l12))) # 对t12可变对象: copy.copy外壳仅实现浅拷贝</span><br><span class="line">print(&#39;l1:&#123;&#125;;\tt12元素0:&#123;&#125;;\tcc_t12元素0:&#123;&#125;&#39;.format(id(l1),id(l12[0]),id(cc_l12[0]))) #  copy.copy内部元素也仅仅实现了浅拷贝:t12的元素0就是l1对象本身; 而cc_t12元素0也是l1对象本身</span><br></pre></td></tr></table></figure></li>
<li><p>图示</p>
<ul>
<li><img src="/24464/python%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.jpg" class="" title="python深浅拷贝">
</li>
</ul>
</li>
<li><p>例外事项(2019年8月24日 补充)</p>
<ul>
<li>昨日学弟问起函数对象为何无法进行深拷贝的问题,以下是代码:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">def greet():</span><br><span class="line">    print(&#39;hw.&#39;)</span><br><span class="line">d_greet&#x3D;copy.deepcopy(greet)</span><br><span class="line">print(&#39;greetID:&#123;&#125;;\td_greetID:&#123;&#125;&#39;.format(id(greet),id(d_greet))) # 可以看出id是一致的, 说明没有完成深复制</span><br></pre></td></tr></table></figure></li>
<li>能有这样的意识, 其实已经说明该学弟python水平已经非同小可了(甚至想推荐他学一波lambda演算~</li>
<li>然而, 文档的重要性还是要继续重申, 以下文档中搜索”unchanged”就可以查到:<a href="https://docs.python.org/3/library/copy.html">It does “copy” functions and classes (shallow and deeply) by returning the original object</a></li>
</ul>
</li>
<li><p>感言</p>
<ul>
<li>后生可畏, 中年失业什么的还是尽早有准备和觉悟才好.</li>
<li>文档的重要性还是要多重申几次呀, 不要因为库的局限性而浪费了自己的时间, 甚至于怀疑自身的逻辑性什么的真是大可不必.</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>python装饰器_斐波那契计时器</title>
    <url>/31338/</url>
    <content><![CDATA[<p>装饰器的实例1-代码计时器,说明都写在代码注释中了~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def wrapper(*arguments,**keyword_arguments): # 参数有无与多少不确定, 关键字参数有无与多少不确定</span><br><span class="line">        start&#x3D;time.time()</span><br><span class="line">        ret&#x3D;func(*arguments,**keyword_arguments) # 与前文类似, 参数有无与多少不确定</span><br><span class="line">        end&#x3D;time.time()</span><br><span class="line">        print(&#39;FuncName:&#123;&#125;;\nResult:&#123;&#125;\nTime Spent:\t&#123;&#125;s&#39;.format(getattr(func,&#39;__name__&#39;),ret,end-start),file&#x3D;open(&#39;D:\跑速情况.txt&#39;,&#39;a&#39;))</span><br><span class="line">        # 可以先dir(func) 查出func有__name__这个attr, 于是用函数getattr(funcName, funcAttrName)</span><br><span class="line">        return ret # 很关键, 因为func有返回值所以要写ret(其实没有返回值也写一下没什么问题)</span><br><span class="line">    return wrapper # 装饰器本质: ret内层函数</span><br><span class="line"></span><br><span class="line"># 注意: 带参数的装饰器指的是装饰器有参数, 就是最外层的timer(func,args),</span><br><span class="line">## 被装饰函数有参数, 直接在内部处理就可以, ret&#x3D;func(*arguments,**keyword_arguments)</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def m1_feibonaqi(n,visited&#x3D;[]): # 改进版递归型斐波那契, 区分于远坂sb无脑递归型在于加入visited使得不用重复计算</span><br><span class="line">    if n&#x3D;&#x3D;1 or n&#x3D;&#x3D;2:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        if bool(visited)&#x3D;&#x3D;0:</span><br><span class="line">            ori_visited&#x3D;[1,1].extend([None for each in range(3,n+1)])</span><br><span class="line">            visited&#x3D;ori_visited</span><br><span class="line">        else:</span><br><span class="line">            if visited[n-2]&#x3D;&#x3D;None:</span><br><span class="line">                tail&#x3D;m1_feibonaqi(n-2)</span><br><span class="line">                visited[n-2]&#x3D;tail</span><br><span class="line">            if visited[n-1]&#x3D;&#x3D;None:</span><br><span class="line">                head&#x3D;m1_feibonaqi(n-1)</span><br><span class="line">                visited[n-1]&#x3D;head</span><br><span class="line">            return visited[n-1]+visited[n-2]</span><br><span class="line">        return m1_feibonaqi(n-1)+m1_feibonaqi(n-2)</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def m1_feibonaqi(n): # sb无脑递归型, 可以拿来测下栈帧深度</span><br><span class="line">    if n&#x3D;&#x3D;1 or n&#x3D;&#x3D;2:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return m1_feibonaqi(n-1)+m1_feibonaqi(n-2)</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def m2_feibonaqi(n): # 正常型斐波那契</span><br><span class="line">    if n&#x3D;&#x3D;1 or n&#x3D;&#x3D;2:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        f1,f2&#x3D;1,1</span><br><span class="line">        head,tail&#x3D;f2,f1</span><br><span class="line">        cnt&#x3D;2</span><br><span class="line">        while cnt&lt;n:</span><br><span class="line">            cnt+&#x3D;1</span><br><span class="line">            next_val&#x3D;head+tail</span><br><span class="line">            head,tail&#x3D;next_val,head</span><br><span class="line">        return next_val</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def m3_feibonaqi(n,visited&#x3D;[]): # 改进版递归型斐波那契, 区分于远坂sb无脑递归型在于加入visited使得不用重复计算</span><br><span class="line">    if n&#x3D;&#x3D;1 or n&#x3D;&#x3D;2:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        if bool(visited)&#x3D;&#x3D;0:</span><br><span class="line">            ori_visited&#x3D;[1,1].extend([None for each in range(3,n+1)])</span><br><span class="line">            visited&#x3D;ori_visited</span><br><span class="line">        else:</span><br><span class="line">            if visited[n-2]&#x3D;&#x3D;None:</span><br><span class="line">                tail&#x3D;m1_feibonaqi(n-2,visited)</span><br><span class="line">                visited[n-2]&#x3D;tail</span><br><span class="line">            if visited[n-1]&#x3D;&#x3D;None:</span><br><span class="line">                head&#x3D;m1_feibonaqi(n-1,visited)</span><br><span class="line">                visited[n-1]&#x3D;head</span><br><span class="line">            return visited[n-1]+visited[n-2]</span><br><span class="line">        return m3_feibonaqi(n-1,visited)+m3_feibonaqi(n-2,visited)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m1_feibonaqi(10) # 这个只能跑20以内的</span><br><span class="line">print(&#39;----分界线12----&#39;,file&#x3D;open(&#39;D:\跑速情况.txt&#39;,&#39;a&#39;))</span><br><span class="line">m2_feibonaqi(10**5) # 这个可以跑10万以内的</span><br><span class="line">print(&#39;----分界线23----&#39;,file&#x3D;open(&#39;D:\跑速情况.txt&#39;,&#39;a&#39;))</span><br><span class="line">m3_feibonaqi(10) # 这个也同样只能跑20以内的</span><br><span class="line"></span><br><span class="line">## 实际上m1和m3跑出来结果是一样的(^7$7^), 难受~</span><br></pre></td></tr></table></figure>
<p>希望大家能够更清楚地了解装饰器的实质与用法, 以后依据不同的需求我估计还会写一些其他的~</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-set-nightly-jetbrains</title>
    <url>/9740/</url>
    <content><![CDATA[<img src="/9740/Screenshot_20201016_114247.jpg" class="">
]]></content>
  </entry>
  <entry>
    <title>win10下配置ubuntu1804基本情况总结</title>
    <url>/57668/</url>
    <content><![CDATA[<p>要做什么:</p>
<ol>
<li>vmware内安装ubuntu1804</li>
<li>设置共享文件夹</li>
<li>vmware无界面启动 &amp;&amp; xshell进行ssh连接</li>
</ol>
<p>几点注意:</p>
<ol>
<li>每次下载大文件or大型软件时, 第一个念头是google搜换源, 第二个念头是硬盘备份(可以方便很多同学…)</li>
<li>vmware下载后破解码附带在备份的硬盘内(省得下次再找)<img src="/57668/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B3%A8%E5%86%8C%E7%A0%81.png" class="" title="虚拟机注册码"></li>
<li>虚拟机安装在ubuntu1804Home下,目录树结构,硬件分配见图<img src="/57668/%E7%9B%AE%E5%BD%95%E6%A0%91%E7%BB%93%E6%9E%84.png" class="" title="目录树结构">
<img src="/57668/%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%83%85%E5%86%B5.jpg" class="" title="硬件配置情况"></li>
<li>共享文件夹设置的时候虚拟机必须是<em>关机</em>状态而不是<em>挂起</em>或其他,右键点开”虚拟机设置”<img src="/57668/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AE%BE%E7%BD%AE.jpg" class="" title="共享文件夹设置"></li>
<li>可以设置无界面启动的,具体见<a href="https://blog.csdn.net/forest_boy/article/details/49931505">这里</a>,启动无界面虚拟机代码<br><code>vmrun -T ws start &quot;D:\SubSystem1804\Ubuntu1804\Linkeer365Ubuntu&quot; nogui</code></li>
<li>linux命令行下ifconfig得到虚拟机的ip地址(没有的话,就先<code>sudo apt install net-tools</code>什么的,会有提示的…)<br>然后xshell直连本机ssh走一波(感谢林煜堃老哥,帮了大忙了这次…)</li>
<li>加入xshell的时候用户名记得要全部小写(不能出现大写字母!否则一直报错:ssh拒绝了密码)</li>
</ol>
<p>锦上添花:</p>
<ol>
<li><p>定制windows的sentTo功能, 使得文件可以直接发到ubuntuWinShare中(xshell负责发送也可以,当然也可以靠listary定制一个目录项…)</p>
</li>
<li><p>把vmrun写到用户环境变量里面, 然后定制.bashrc, 把vmx的path设置为alias, 写一些小函数, Like this:</p>
<img src="/57668/bashrc%E5%85%B3%E4%BA%8Evmx%E7%9A%84%E5%87%BD%E6%95%B0.jpg" class="" title="bashrc关于vmx的函数">
</li>
<li><p>思考一下, 怎样把git bash定制成不输cmd的命令行?  -&gt; 核心问题: <code>如何使用git bash 进行(托管)系统环境变量的读写呢?</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>配置教程</tag>
      </tags>
  </entry>
  <entry>
    <title>win10配置clang到clion中</title>
    <url>/38389/</url>
    <content><![CDATA[<p>考虑到主页<a href="https://www.zhihu.com/question/351744551/answer/865665382">千里冰封</a>的推荐, 我去安装了试试, 以下是简要记录(我的运气还是挺好的, 至少没有看到一些劝退的帖子, 安装过程算是非常顺利的一次了…)</p>
<ol>
<li>根据<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">这里</a>我们知道一共有3件事要做, {安装mingw64和msys2}-{在msys2中安装llvm和clang}-{在clion中配置cmake和toolchain选项}</li>
<li>安装mingw64和msys2不用提了…</li>
<li>在msys2中安装llvm和clang,命令是<code>pacman -S mingw-w64-x86_64-llvm</code>和<code>pacman -S mingw-w64-x86_64-clang</code>(注意有先后)都懂得, 只要一涉及这种命令行下载东西的时候, 就立马先到网上查一下”换源”什么的, 于是搜索”msys2 换源”, 然后在<a href="https://mirror.tuna.tsinghua.edu.cn/help/msys2/">这里</a>找到了答案, 这就是一种意识, 很多时候应该变成一种条件反射的东西, 哦一旦出现命令行下载东西就立马换源换源…如果不是命令行的话呢, 就请买一个IDM, 你会发现你后半生的下载会非常自在的…</li>
<li>clion中的配置过程, 首先按照<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">原网页</a>上面显示的配置cmake选项的确是OK的, 那个CC={sth1}, CXX={sth2}一看就知道是环境变量里面的键值对, 所以直接将CC和CXX配置到环境变量里头去即可, 但并没有结束, 此处没有考虑到toolchain的情况, 下面是toolchain的配置.</li>
<li>根据<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000394670-How-can-I-configure-LLVM-Clang-6-0-with-CLION-2018-1">这里</a>我们找到这段话<code>You can&#39;t use clang in CLion on Windows without having MinGW or Cygwin installed. You can try the following:</code>, 说明我们还是要把mingw放在Environment下, 只是make的工具全部换成clang系列的即可 (还有就是能让clion自己detect就不必手动加入绝对路径了…), 这里不多废话, 一图胜千言</li>
<li>第5步图</li>
</ol>
<ul>
<li><img src="/38389/clion_clang%E9%85%8D%E7%BD%AE_toolchain_mingw%E9%83%A8%E5%88%86.jpg" class="" title="clion_clang配置_toolchain_mingw部分"></li>
<li><img src="/38389/clion_clang%E9%85%8D%E7%BD%AE_toolchain_clang%E9%83%A8%E5%88%86.jpg" class="" title="clion_clang配置_toolchain_mingw部分"></li>
</ul>
<ol start="7">
<li>成果是这样的</li>
</ol>
<ul>
<li><img src="/38389/clang%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.jpg" class="" title="clang报错信息"></li>
<li>下次试着把cl.exe也安装上去, 看看每家编译器的水准如何hh~</li>
</ul>
]]></content>
      <tags>
        <tag>clion</tag>
        <tag>clang配置</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>win10键盘驱动损坏修复记录</title>
    <url>/44181/</url>
    <content><![CDATA[<p>今天在使用Total Uninstaller删除Vmware的时候, 删除了部分注册表项, 造成了许多问题, 以下进行记录.</p>
<h1 id="意识的问题"><a href="#意识的问题" class="headerlink" title="意识的问题"></a>意识的问题</h1><ol>
<li>注册表项是宁滥勿缺, 缺少特定表项可能引发严重后果</li>
<li>Vmware作为虚拟机程序, 内部可能会读写win10系统的驱动注册表项(但外部是看不见的), 删除Vmware的时候清理注册表很容易造成误伤</li>
</ol>
<h1 id="纠正措施的错误之处"><a href="#纠正措施的错误之处" class="headerlink" title="纠正措施的错误之处"></a>纠正措施的错误之处</h1><ol>
<li>错误地认为win10更新能重建注册表(这种错误我们一般称为一厢情愿, 应然与实然的问题)</li>
<li>没有对win10更新过程进行计时(因为我们都知道win10更新相当不靠谱, 可还是疏于防范), 强行重启的止损时间还是不够快.</li>
<li>由于win10更新安装不完全, 缺省进入的rollback system无限重启, 重复多次而忘记考虑安全模式启动</li>
</ol>
<h1 id="纠正措施的正确之处"><a href="#纠正措施的正确之处" class="headerlink" title="纠正措施的正确之处"></a>纠正措施的正确之处</h1><ol>
<li>及时猜出是因为删除Vmware引发的驱动问题, 查看设备管理器后发现驱动正常而无法找到注册表, 定位到注册表问题</li>
<li>在win10安装更新失败后及时调整战略, 避免更大的影响.</li>
<li>判定<code>win10无法进入原系统(当然也无法进入rollback)</code>与<code>键盘驱动问题</code>是相对独立的两个问题, 拟定计划: <code>先进入原系统解决完驱动问题</code> -&gt; <code>最后再解决rollback问题</code></li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li><code>针对注册表项</code>:解铃还须系铃人, 从winr手动进入total uninstaller发现能够恢复注册表项, 逃出升天(不然就真的没了)</li>
<li><code>针对rollback系统</code>:网上查找教程</li>
</ol>
<h1 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h1><ol>
<li>如何进行注册表的备份?</li>
<li>如何保证注册表不在安装软件的过程中被删改?</li>
</ol>
<h1 id="结论-amp-amp-反思"><a href="#结论-amp-amp-反思" class="headerlink" title="结论 &amp;&amp; 反思"></a>结论 &amp;&amp; 反思</h1><ol>
<li>注册表项宁可添加,不要删改</li>
<li>一些情况下保持冷静, 复杂问题的拆分与归并是需要好好design的</li>
<li>Vmware竟然能够写入驱动的注册表, 那是不是他也可以顺便对我的所有键盘输入进行监控与收集呢?<br>要是我(有人)发布一些有木马的虚拟机软件, 是不是本地主机的安全性可能因此受到影响?</li>
</ol>
]]></content>
      <tags>
        <tag>win10</tag>
        <tag>win10更新</tag>
      </tags>
  </entry>
  <entry>
    <title>windows如何将redis设置为后台运行（注册为服务）</title>
    <url>/58592/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/yikong2yuxuan/article/details/73195654">windows 下redis在后台运行</a></p>
<ol>
<li><p>进入 DOS窗口</p>
</li>
<li><p>在进入Redis的安装目录</p>
</li>
<li><p>输入：<code>redis-server --service-install redis.windows.conf --loglevel verbose</code> ( 安装redis服务 )</p>
</li>
<li><p> 输入：<code>redis-server --service-start</code> ( 启动服务 )</p>
</li>
<li><p>输入：<code>redis-server --service-stop</code> （停止服务）</p>
</li>
</ol>
<p>启动指定的配置文件<code>redis-server --service-start redis.windows-service.conf</code></p>
]]></content>
  </entry>
  <entry>
    <title>使用babun实现windows下git-zsh双全</title>
    <url>/18267/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><ul>
<li>因为不知道做错了什么事遭到了可敬的人的讨厌, 这样的事于我已不鲜见, 然而心情还是难以平复的, 好像再次变回了曾经的顽劣少年.</li>
<li>好在babun下配置git-zsh的成功, 多多少少平复了一点苦辛.</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>git bash在windows下能顺利配置成功, 说明其实至少在shell这一方面, windows是可以兼容unix系统的. 此时自然可以联想到, zsh, fish这些声名远扬的shell, 是不是也能在windows下谋得一席之地呢?</li>
<li>但是 win10自带的wsl我不是很喜欢用, 因为<ul>
<li>它是一款Windows App, 而这种App我不知道他放在哪里, </li>
<li>也不知道它对我的电脑做出过/会做出怎样的修改, 由此便容易生疑, 会不会造成潜在的隐患呢? </li>
<li>还有就是 怎么一气儿将他卸载干净呢? (林林总总的很多小问题…)</li>
</ul>
</li>
<li>相比WSL, babun好处是<ul>
<li>可以直接安装在D:/WholeBabun文件夹下, 这样逃不出手掌心</li>
<li>可以一口气卸载干净</li>
<li>后续如果有安全问题, 用沙盒去检测这个文件夹就可以了</li>
</ul>
</li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul>
<li>配好babun</li>
<li>配好cmder(不配也可以)</li>
<li>(一般git已经配置好了), 在~文件夹新建.ssh空文件夹</li>
<li>把原来的.ssh文件夹内的文件全部拷过去</li>
<li>(如果遇到hexo重复输密码问题) 查看_config.yml文件(根目录下的 项目管理文件) 下面的deploy-repo文件, 如果是https开头的网址, 请改成git开头的网址, 类似这样:<ul>
<li>https开头网址  -&gt; <code>https://github.com/yourName/yourName.github.io.git</code></li>
<li>git开头网址  -&gt; <code>git@github.com:yourName/yourName.github.io.git</code></li>
<li>解法源于这位大佬<a href="https://segmentfault.com/a/1190000005125610">程建华</a></li>
<li>网址不自动生成超链接的办法: 用” ` “把website包起来.</li>
</ul>
</li>
</ul>
<h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><ul>
<li><p>许多时候, 人还是必须要参照外物而活着的,这完全不是一种让渡和同流合污的体现, 只是一种更加严谨客观的角度去思考自身是否有问题的手段</p>
</li>
<li><p>很多例子证明人随着年纪增大会越发顽固, 我也不想违背自然规律, 我以后肯定也会越变越顽固的, 但是我对真诚和善意的追寻, 对人类美好未来的期许我是一生都不想也不愿改变的, 但是天道的无常谁有能说这不是一个flag呢?</p>
</li>
<li><p>屠龙的勇者可能变成了龙, 但是作为一条龙, 是不是也可能有着一往无前的鲜烈过去, 赤胆忠心的流金岁月呢? 但是他们都无比幸运的死在同为勇者的知己的刀剑之下, 而非鼠辈们肮脏的冷枪中. 类似地, 如果有一天我真的变成了这些美好品质的敌人, 谁又能充当介错我的洋葱骑士呢? 悠悠苍天！曷其有常?</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>babun</tag>
        <tag>windows-based unix</tag>
        <tag>git</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>全体编辑器自动保存 &amp; settings文件收集整理</title>
    <url>/53238/</url>
    <content><![CDATA[<p>缘起:</p>
<ul>
<li>听说有人资料遗失痛不欲生, 罪魁祸首是忘记保存, 因此, 所有涉及到原创的资料都要设置自动保存.</li>
<li>如果电脑崩溃, 资料尽管已经保存好, 然而纷繁的设置却同样令人头疼, 因此settings文件也要定期导出并备份.</li>
</ul>
<p>思路:</p>
<ul>
<li>“自动保存”是settings的一种, 所以实质是解决settings保存问题.</li>
<li>设置自动保存后, “此项设置”往往也在settings文件夹内, 故要先设置自动保存, 再设置settings文件备份</li>
<li>settings文件往往不大, 故可以用其中一个repo来存储它</li>
</ul>
<p>流程:</p>
<ul>
<li><p>通过manictime, 得到这些天来动用过哪些编辑器</p>
<ul>
<li>cent浏览器(no)</li>
<li>Adobe Reader, 福昕阅读器(no)</li>
<li>Jetbrains三兄贵, pycharm, Clion, Idea(yes)</li>
<li>vscode(yes)</li>
<li>notepad++(no)</li>
<li>搜狗输入法(云端, 不需要)</li>
<li>Office三件套,ppt, excel, word(太少,不需要)</li>
<li>listary日常搞姬(yes)</li>
<li>nomeiryo 字体修改(yes)</li>
</ul>
</li>
<li><p>对这些编辑器设置自动保存</p>
<ul>
<li>cent浏览器<ul>
<li>记得登录谷歌, 实现书签与插件的自动保存</li>
<li>好像不支持settings导出emmm</li>
</ul>
</li>
<li>Adobe Reader, 福昕阅读器<ul>
<li>好像不支持settings的导出?</li>
</ul>
</li>
<li>Jetbrains三兄贵<ul>
<li>自动保存: <ul>
<li>Settings &gt;&gt; Apperance &amp; Behavior &gt;&gt; System Settings &gt;&gt; Save files on frame deactivation automatically(180sec)</li>
</ul>
</li>
<li>导出设置:<ul>
<li>自动保存完后请先关闭再打开</li>
<li> File &gt;&gt; Export settings</li>
</ul>
</li>
</ul>
</li>
<li>vscode<ul>
<li>自动保存:<ul>
<li>File &gt;&gt; Preferences &gt;&gt; settings &gt;&gt; 搜索”Autosave” &gt;&gt; afterdelay &gt;&gt; 180000ms</li>
</ul>
</li>
<li>导出设置:<ul>
<li>随便找一个.vscode文件, 复制settings.json和tasks.json并压缩即可</li>
</ul>
</li>
</ul>
</li>
<li>office三件套:<ul>
<li>自动保存:<ul>
<li>文件-选项-保存-1分钟</li>
</ul>
</li>
<li>导出设置: 选项太少, 可以忽略</li>
</ul>
</li>
<li>notepad++<ul>
<li>自动保存:<ul>
<li>重装32bit版本, 安装<a href="https://github.com/bruderstein/nppPluginManager/releases">plugins manager</a>, 新建把plugins文件夹内的pluginManager放在安装目录plugins下面</li>
<li>plugin Manager下找autosave插件, 随后进行设置</li>
</ul>
</li>
<li>导出设置:<ul>
<li>只进行插件的备份?</li>
</ul>
</li>
</ul>
</li>
<li>listary<ul>
<li>导出设置: Roaming下userdata</li>
</ul>
</li>
<li>字体Nomeiryo<ul>
<li>直接保存字体即可</li>
</ul>
</li>
</ul>
</li>
<li><p>导出这些编辑器的设置, 并每月设置提醒更新这些设置</p>
</li>
<li><p>统合settings文件, 上传百度云盘(github太小放不下)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>自动保存</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭qq安全防护更新进程</title>
    <url>/11308/</url>
    <content><![CDATA[<p><a href="https://jingyan.baidu.com/article/6b97984db76d911ca2b0bfa0.html">https://jingyan.baidu.com/article/6b97984db76d911ca2b0bfa0.html</a></p>
<p><a href="https://www.zhihu.com/question/34861467">https://www.zhihu.com/question/34861467</a></p>
]]></content>
  </entry>
  <entry>
    <title>单个github账户写多个博客</title>
    <url>/7487/</url>
    <content><![CDATA[<h1 id="发心"><a href="#发心" class="headerlink" title="发心"></a>发心</h1><ul>
<li>最近想写日记, 日记就不仅仅能够记录技术, 还能刻画内心情感上的成长, 那么需要再建一个日记博客</li>
<li>初步的想法是再次申请一个github账号进行专门的日记写作, 然而我潜在觉得此后保存公钥私钥会成为更大的问题,遂放弃</li>
<li>从<a href="http://chitanda.me/2015/11/03/multiple-git-pages-in-one-github-account/">千反田酱</a>了解到github可以无限定义”项目主页”, 这实际上就是博客的雏形了</li>
</ul>
<h1 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h1><ul>
<li>网上流传的需要将项目名称改为gh-pages我自己没有证实, 故无法判断真假</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li><p>在md文件暴露的情况下, 如何做到加密?</p>
<ul>
<li><p><del>我没有pro账号, 因此github pages都必须要public,同时我还要将md源文件上传至同样public的hexo分支, 而市面上的插件, 往往需要将passwd明文写在md源文件中, 那坏蛋们只要看一看我hexo中的md源文件, 不就直接可以明文得知密码了吗? 那这个插件岂不是搞笑</del></p>
<p><del><code>(我说的就是你, hexo-blog-encrypt插件!密码必须明文放在md文件里才能上锁简直搞笑!)</code><del></p>
</li>
<li><p><del>需要找一款插件, 我可以将密码保存在本地文件中(或者新建一个private repo去存他也完全可以), 然后这些设置文件我可以不用上传, 在md文件中, 我只用写一条<code>encrypt:true</code>即可声明我使用了默认密码, 反正现在的我也只需要使用默认密码</p>
</del></li>
<li><p>(2019年10月7日08:00:13)上面这个家伙在胡言乱语, 我不认识他. =&gt; <code>你TM都有md文件了, 人家点选md在线预览不就完事了, 跟你有没有密码有何关系? 锁还没挂门上就先考虑钥匙, 唉~</code></p>
</li>
<li><p>其余更新在”加密更新”一栏</p>
</li>
</ul>
</li>
</ul>
<h1 id="以下警示-这些可以作为一篇新博客教程-但加密功能有误-相见”更新”-请注意"><a href="#以下警示-这些可以作为一篇新博客教程-但加密功能有误-相见”更新”-请注意" class="headerlink" title="以下警示, 这些可以作为一篇新博客教程, 但加密功能有误(相见”更新”)请注意!"></a><b>以下警示, 这些可以作为一篇新博客教程, 但加密功能有误(相见”更新”)请注意!</b></h1><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><b> 请务必按照步骤一步步实现 </b></p>
<h2 id="github-操作部分"><a href="#github-操作部分" class="headerlink" title="github 操作部分"></a>github 操作部分</h2><ol>
<li>新建repo, repo必须是public的</li>
<li>settings - github pages- 下拉菜单选master(不知道选master docs可不可以, 没试过)</li>
<li>(在网页上手动)新建hexo分支, 并设为默认</li>
</ol>
<h2 id="本地建立hexo博客"><a href="#本地建立hexo博客" class="headerlink" title="本地建立hexo博客"></a>本地建立hexo博客</h2><ol>
<li><p>博客文件夹必须要和你的repo同名, 注意!</p>
</li>
<li><p>有旧博客的将旧博客拷贝过来, 需要保留这些文件</p>
</li>
</ol>
<ul>
<li>node_modules(这个其实可有可无)</li>
<li>themes(我装了next, 不想再装一次)</li>
<li>source(记得清一下博客部分, 文件夹只留一个_posts即可)</li>
<li>scaffolds</li>
<li>package.json和package-lock.json</li>
<li>.gitignore</li>
<li>_config.yml(这个最重要, 建议备份一下,但要做一些小修改)</li>
</ul>
<ol start="3">
<li>没有旧博客, 直接hexo init &lt;博客名&gt;</li>
</ol>
<h2 id="github与hexo的结合"><a href="#github与hexo的结合" class="headerlink" title="github与hexo的结合"></a>github与hexo的结合</h2><ol>
<li>确认一下有没有新建hexo分支, 并设为默认, 两项都必须落实!</li>
<li>完成1后, git clone到diary文件夹下<ul>
<li>注意, .git没错的确不能嵌套使用, 但是.git文件是可以移动到其他文件夹下面的, 如果出现/diary/diary/.git情况, 可以直接把.git文件夹和readme.md移出来, 这个是专门给我这种强迫症看的</li>
<li>.git文件要和source在同一层级, 这样才便于使用hexo官方给的gitignore文件</li>
</ul>
</li>
<li>修改_config.yml几处地方<ul>
<li>url, root: 修改成child文件夹(注释中的child指的就是你的repo文件名, 也就是github你repo的名字)<br>比如我的是:<br><code>url: http://yoursite.com/Linkeer365Diary</code>以及<code>root:/Linkeer365Diary/</code></li>
<li>repo: 修改成新的repo名<br>比如我的是:<br><code>https://github.com/Linkeer365/Linkeer365Diary.git</code>这里注意, 不能用<code>git@github.com</code>开头, 此处的报错我也一直没有搞清楚原因.</li>
<li>添加一段代码<code>encrypt:\n\tpassword: &lt;YourDefaultPasswd&gt;</code>, 这样你就可以使用默认密码了.</li>
</ul>
</li>
</ol>
<h2 id="快捷键更新"><a href="#快捷键更新" class="headerlink" title="快捷键更新"></a>快捷键更新</h2><ol>
<li>增加下你的.bashrc里面的alias快捷键, 以前的br(blog root), 现在就加一个dr(diary root), 这些就无须多言了</li>
</ol>
<h2 id="文档加密插件"><a href="#文档加密插件" class="headerlink" title="文档加密插件"></a>文档加密插件</h2><ol>
<li>不多说了, 直接扔博客:<br><a href="https://blog.bill.moe/encrypt/">Bill Yang巨佬</a></li>
<li>另外:</li>
</ol>
<ul>
<li><a href="https://blog.bill.moe/tags/Hexo/">他的hexo建设记录</a></li>
<li><a href="https://blog.bill.moe/">他的主页</a></li>
<li><a href="https://blog.bill.moe/friends/">兄贵们</a></li>
</ul>
<ol start="3">
<li>AWSL ↑</li>
</ol>
<h1 id="加密更新-2019年10月7日08-02-18"><a href="#加密更新-2019年10月7日08-02-18" class="headerlink" title="加密更新(2019年10月7日08:02:18)"></a>加密更新(2019年10月7日08:02:18)</h1><pre><code>- 我承认我就是上面那个SB
- 正确做法, 直接新建private repo -&gt; diarySource(以前的.git和readme先删了) 然后和在source同级目录下git clone, 把git和readme移出来(.git和source要保持同级)即可.</code></pre>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="为什么想写日记-amp-amp-吹一波汤浅政明"><a href="#为什么想写日记-amp-amp-吹一波汤浅政明" class="headerlink" title="为什么想写日记 &amp;&amp; 吹一波汤浅政明"></a>为什么想写日记 &amp;&amp; 吹一波汤浅政明</h2><p>记日记的发心, 源于最近看的一部动漫, 汤浅政明的《海马》(kaiba), 看得我真的只想在汤浅面前长跪不起, 以前我老是把汤浅政明归入伊藤润二这类先锋艺术家, 老是觉得他喜欢耍滑头搞猎奇, 《春宵苦短》《四叠半》什么的我都认为沾了原作者森见登美彦的光, </p>
<p>但事实就是, 森见很牛, 汤浅政明也很牛, 这部片子的广角镜头的走位感, 情节的松紧度, 甚至包括对爱情的刻画的含蓄感, 都恰到好处, 就像一个年轻的武术高手, 势大力沉却不失灵动, 甚至后期有点快得飞起的情节, 我都觉得像一直喜欢的苦味冰淇淋, 冰淇淋一定要有咸苦的觉悟, 才能做到脱俗, 才能发掘出新奇的口感, 或者至少有新口感的潜能.</p>
<h2 id="kaiba跟写日记有什么关系"><a href="#kaiba跟写日记有什么关系" class="headerlink" title="kaiba跟写日记有什么关系"></a>kaiba跟写日记有什么关系</h2><p>warp是记忆之王, 他尚且会因为各种各样的风波而失去记忆(到最后为了退治吃记忆的植物kaiba也再次丢掉了所有记忆), 我们显然不可能有这个能力和权限,所以我们的记忆就更应该好好的用文字和电子资料记录下来, 这样以后哪天我变得很邪恶很下作很龌龊的时候, 请大家拿着我的日记告诉我, 你曾经是一个这样的人, 不要丢掉曾经的你.如果我不能改变的话, 也请大家知道我曾经是另一幅样子, 只是人在多变的时代和无常的际遇两者面前, 气节和派头终究都显得太过可笑了.</p>
<h2 id="日记主要包括哪些内容-侧重点在哪里"><a href="#日记主要包括哪些内容-侧重点在哪里" class="headerlink" title="日记主要包括哪些内容? 侧重点在哪里 ?"></a>日记主要包括哪些内容? 侧重点在哪里 ?</h2><p>虽然日记一定每篇都会加密, 这点不可商量的, 但是可以透露的是, 我的日记主要包括我自己一天的情感变化和生理变化(情感变化就是开心或者悲伤, 生理变化就是一些或粗或细的非固定参数), </p>
<p>而侧重点主要在今天身边或体内发生的奇怪或难忘的事件(比如两年前高考完的那个暑假, 我独立推想出了”物自体”的客观存在, 这一点在最近读康德的时候才突然strike on me, 就感觉<code>啊我的智慧真是跨越时空</code>什么的~, 这个就属于体内发生的; 或者今天凌晨时分我在出租车上莫名感受到司机的绝望感与无力感, 于是苦劝,希望他不要想到自杀,这个动作现在很普遍了, 甚至还为此绕了远路, 这样的事情就属于体外发生的), </p>
<p>我觉得这样多多少少能够映照历史, 虽然这就像<code>&quot;难道月亮会因为人不写诗而黯淡半分吗&quot;</code>(俄罗斯谚语, 好像是《卡尔马佐夫兄弟》里面的, 有点忘了)一样的可笑与荒谬, 但无能如我, 这样大概就能欣慰一点, 这大概也和四季映姬”无罪者唯华鸟风月耳”的见解有点突兀地不谋而合了.</p>
<h1 id="2019年10月8日08-32-19-总结一下"><a href="#2019年10月8日08-32-19-总结一下" class="headerlink" title="(2019年10月8日08:32:19) 总结一下"></a>(2019年10月8日08:32:19) 总结一下</h1><h2 id="项目博客github-pages服务开通"><a href="#项目博客github-pages服务开通" class="headerlink" title="项目博客github pages服务开通"></a>项目博客github pages服务开通</h2><ul>
<li>已经申请过github.io的个人账户, 必须开通”项目博客”并激活github pages服务, 才能实现多个博客的创建<h2 id="clone旧博客的hexo作为新的hexo配置文件"><a href="#clone旧博客的hexo作为新的hexo配置文件" class="headerlink" title="clone旧博客的hexo作为新的hexo配置文件"></a>clone旧博客的hexo作为新的hexo配置文件</h2></li>
<li>创建新博客时, 可以直接git clone旧博客的hexo branch完成hexo init和其他的(主要是两个_config.yml)的设置.<h2 id="加密信息上传到新建的private-repo中"><a href="#加密信息上传到新建的private-repo中" class="headerlink" title="加密信息上传到新建的private repo中"></a>加密信息上传到新建的private repo中</h2></li>
<li>需要加密的, 请再开一个private repo存放你的source文件, 此时你不能用新博客的hexo分支来存放source文件,因为md文件会被明文读取; 此时你应该删除旧的.git文件, 添加来自private repo的新.git文件, 放置于同一文件夹下, 然后查看git push等等即可.</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github pages</tag>
        <tag>github项目博客</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows下使用stack配置基于vscode的简易版Haskell开发环境</title>
    <url>/53092/</url>
    <content><![CDATA[<p>Haskell的IDE稀少且难以配置,从前天至今日累计花费6小时才成功,以下是配置记录. </p>
<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul>
<li>(先吐个槽,许多教程漏洞百出, 浪费大家时间, 此处先看我推荐的这些网站, 避免走弯路)</li>
<li><a href="https://segmentfault.com/a/1190000018257284">蒟蒻中蒟蒻</a><ul>
<li>虽是在*nix下的, 但是windows也适用.</li>
<li>这篇文章步骤存在一定问题: 在看完全文前请不要提前操作!</li>
</ul>
</li>
<li><a href="https://github.com/hellmonky/note/blob/master/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%85%B3%E4%BA%8Evscode%E6%90%AD%E5%BB%BAh%E7%8E%AF%E5%A2%83%E7%9A%84%E8%BF%87%E7%A8%8B.md">hellmonky</a><ul>
<li>这篇文章很不错, 但该篇侧重”Haskell工程项目”的IDE搭建, 与本篇所介绍的”简易版”有所出入.</li>
<li>这篇文章适合”使用Haskell创建大型项目”的用户参考, 再次重申, 本文搭建的是”简易版”开发环境.</li>
</ul>
</li>
</ul>
<h1 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a>当前环境</h1><ul>
<li>Windows 10.0.17763</li>
</ul>
<h1 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h1><ul>
<li>stack安装</li>
<li>vscode下Haskell插件5个依赖程序安装</li>
<li>vscode插件路径配置与hs程序调试</li>
</ul>
<h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ul>
<li>参考第一篇<a href="https://segmentfault.com/a/1190000018257284">蒟蒻中蒟蒻</a></li>
<li>安装stack: 点<a href="https://docs.haskellstack.org/en/stable/install_and_upgrade">这里</a>进行下载.<ul>
<li>我个人希望stack自动更新, 所以我默认安装C盘, 想安装在D盘的朋友请看<a href="https://notes.shinemic.cn/setting-up-haskell-stack-development-environment/">这篇文章</a></li>
<li>我个人喜欢自己操作Path环境变量, 所以安装过程中有2个自动Add Path to C:/sc的选项我没有涂黑勾选, 类似下图这样:</li>
<li><img src="/53092/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E4%B8%A4%E4%B8%AA%E9%83%BD%E4%B8%8D%E9%80%89.jpg" class="" title="stack安装过程-两个都不选"></li>
</ul>
</li>
<li>设置环境变量: Path里头加入stack.exe所在文件夹, <ul>
<li>此处设置环境变量意图为: 为stack install提供便利(即不比麻烦地cd到文件夹下)</li>
<li>其实你们要是会用listary的话, 直接<ul>
<li>双击ctrl, 弹出search bar</li>
<li>exe:stack, 找到这个stack.exe文件</li>
<li>ctrl+shift+D, 复制文件所在文件夹到剪贴板中</li>
<li>在Path中粘贴, 一气呵成.</li>
</ul>
</li>
</ul>
</li>
<li>检查cmd下键入stack有没有长长的段落跳出, 有的话执行<code>stack install</code>和<code>stack upgrade</code></li>
<li>需要跳过的选项:<ul>
<li>“使用stack创建你的project”这一栏, stack new, stack setup到stack exec my-project-exe统统不需要!<ul>
<li>原因: 我们搭建的是”简易版”开发环境, 只需要以下功能:<ul>
<li>ghci能交互式运行</li>
<li>在智能提示环境下写好单个hs文件后, 能够运行并调试</li>
</ul>
</li>
<li>那个stack new等等是针对一个大型工程的, 我们不需要.</li>
</ul>
</li>
<li>跳过换源<ul>
<li>原因: 同上</li>
</ul>
</li>
</ul>
</li>
<li>直接来到”搭建vscode”这一栏:<ul>
<li>安装插件: Haskell Syntax Highlighting、Haskell ghc-mod 、haskell-linter、Haskelly;共4个</li>
<li>安装插件依赖: ghc-mod、hlint、intero、QuickCheck、stack-run;共5个<ul>
<li>先安装ghc-mod, 请直接使用这个命令:<ul>
<li><code>stack install ghc-mod --resolver lts-8.24</code></li>
<li>有人会问道stack install后我们已经有lts-14, 请放心, 他们会和平共处的</li>
</ul>
</li>
<li>安装好ghc-mod之后, stack会自动调用ltf-8.24版本, 此时后面的4个插件hlint、intero、QuickCheck、stack-run一定可以一气呵成安装好!</li>
</ul>
</li>
</ul>
</li>
<li>vscode插件路径配置<ul>
<li>新建文件夹HaskellProjects, 加入workplace.</li>
<li>File-Preference-settings里面搜索haskell.ghcMod.executablePath和haskell.hlint.executablePath两项<ul>
<li>在ghcMod和hlint下分别直接填写ghc-mod和hlint!</li>
</ul>
</li>
</ul>
</li>
<li>设置环境变量: Path里头分别加入hlint.exe所在文件夹和ghc-mod.exe文件夹<ul>
<li>一般是同一文件夹, 不同就都加一遍</li>
<li>此处设置环境变量意图为: vscode会自动读取环境变量中的hlint和ghc-mod, 也就是haskell.ghcMod.executablePath和haskell.hlint.executablePath两项会被自动补全!</li>
</ul>
</li>
<li>在HaskellProjects下新建feibonaqi.hs文件<ul>
<li>代码是:  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Main (<span class="title">main</span>) <span class="keyword">where</span></span><br><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n <span class="number">-1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = print $ fib <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li>运行, 成功会返回55.</li>
</ul>
</li>
<li>过河拆桥, 卸载stack<ul>
<li>原因: <ul>
<li>两人幸终: <ul>
<li>stack只是一个类似python中的pip程序, 只是一个托管者.在python-pip-vscode三者之间, 显然没有pip不影响python和vscode</li>
<li>基于这样的逻辑, stack可以出局, 只要Haskell和vscode两人幸终即可.</li>
</ul>
</li>
<li>stack工具人身份:<ul>
<li>依我之见,配置IDE实质:<ul>
<li>使用ghc解释(或解释)并运行hs程序.</li>
<li>利用vscode插件, 对Haskell代码的编写提供智能提示.</li>
</ul>
</li>
<li>正因如此, stack仅仅只是用来安装ghc-mod之类的工具人而已</li>
</ul>
</li>
</ul>
</li>
<li>注意事项:<ul>
<li>不要把compilers也选了, 不然你的ghc.exe会被误杀!</li>
<li>卸载选项图示:<ul>
<li><img src="/53092/%E5%8D%B8%E8%BD%BDstack.jpg" class="" title="注意compilers那项不要选!"></li>
</ul>
</li>
<li>万一一不小心把compilers也卸载了, 补救办法:<ul>
<li>此时插件已经齐了, 只是缺少ghc解释器</li>
<li>直接安装一个Haskell Platform,ghc会随之安装好,其他不用动</li>
<li>(需要环境变量就配置一下)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="GHCI安装"><a href="#GHCI安装" class="headerlink" title="GHCI安装"></a>GHCI安装</h1><ul>
<li>设置环境变量: Path里头加入ghci.exe所在文件夹</li>
<li>顺带一提, winghci配色太outrageous了, 建议命令行下直接操作ghci</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>语言可以认为是被不同解释器或编译器所阐释的文本, 核心在解释器–基于这样的意识, 我一开始就知道需要的仅仅是ghc程序.</li>
<li>智能提示由插件实现, 插件需要特定依赖–基于这样的意识, 我们借用stack安装好各个插件, 即可实现haskell的智能提示.</li>
</ul>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul>
<li>“事不过三” 其实可以解读为: “再困难的问题也超不过3天, 因为3天后你不是解决了就是放弃了.(也可以认为你自己被问题解决了~)”所以类似环境配置这种事, 做所有的事都不必心急, 一天不行就第二天再继续看看, 往往都能3天内得到解决, 解决不了的就暂时认输就好了, 不能总是人去解决问题的呀, 老是这样问题岂不是就很没有面子+(^%=%^)+</li>
</ul>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>IDE配置</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>处处函数化</title>
    <url>/3253/</url>
    <content><![CDATA[<ul>
<li><p>缘起:</p>
<ul>
<li>前文我们尝到了函数化的甜头, 于是我们考虑”处处函数化”的方案</li>
</ul>
</li>
<li><p>思路:</p>
<ul>
<li>alias要保留, 函数可以实现复合功能, 但是单一功能还得由alias负责, 这些单一功能是不能被革命的</li>
<li>函数直接写在bashrc里面, 一共就没几个函数, 但是注释要写好</li>
</ul>
</li>
<li><p>流程:</p>
<ul>
<li>设计两个函数, uguh(upload github &amp; upload hexo)和ohn(outside hexo new)</li>
<li>传参是字符串最好用变量接收一下, 增强可读性<a href="https://blog.csdn.net/alanzjl/article/details/50715870">github自动上传脚本</a></li>
</ul>
</li>
<li><p>图示</p>
<ul>
<li><img src="/3253/%E5%A4%84%E5%A4%84%E5%87%BD%E6%95%B0%E5%8C%96.jpg" class="" title="ohn与upug用法说明"></li>
<li><img src="/3253/%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA.jpg" class="" title="具体代码展示如图"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>git-bash</tag>
        <tag>函数化</tag>
      </tags>
  </entry>
  <entry>
    <title>感觉写得很不错的一篇3100Report</title>
    <url>/23181/</url>
    <content><![CDATA[<h1 id="CSC3100-Assignment-1-Report"><a href="#CSC3100-Assignment-1-Report" class="headerlink" title="CSC3100 Assignment 1 Report"></a>CSC3100 Assignment 1 Report</h1><h5> 姓名: `Sobadatsu Omo` </h5>
<h5> Student ID: `7182`</h5>

<h2 id="Decomposition-of-This-Problem"><a href="#Decomposition-of-This-Problem" class="headerlink" title="Decomposition of This Problem"></a><strong>Decomposition of This Problem</strong></h2><p>The problem is of a composite type. Through a simple decomposition method, we can divide this question into three smaller sections of more generic types. Firstly we need to <strong>read streams of a static scale</strong> through web servers. Secondly we need to <strong>find out the exact positions</strong> of two values of this stream of data. Thirdly we need to <strong>varify a prime number</strong> that was obtained by the subtraction of these two values.</p>
<h2 id="Solutions-for-Each-Section"><a href="#Solutions-for-Each-Section" class="headerlink" title="Solutions for Each Section"></a><strong>Solutions for Each Section</strong></h2><h3 id="Read-Streams-of-a-Static-Scale"><a href="#Read-Streams-of-a-Static-Scale" class="headerlink" title="Read Streams of a Static Scale"></a><strong>Read Streams of a Static Scale</strong></h3><p>To read streams of a static scale through web servers, which can be recognized as a common instance of I/O data transmission. To solve it, we can use Scanner datatype, which is a widely applied file handler and can deal with a wide range of data sorts. I used to stick on it, until a cutting-edged technique “BufferedReader” has been revealed by my two of my friends, Xieguochao and Linyukun. </p>
<p>The idea is that because the whole set of data streams is of the same datatype, so we do not need to worry about being interrupted by some strange data of different types that we do not have certain built-in methods to deal with. On the contract, as for “BufferedReader”, the lack of generic functions can be regarded as a good save without a dummy type examinations in this case.</p>
<p>What’s more, they have the same size which indicate that it can benefit memory alignment and block alignment. So it can be naturally designed to support buffers when dealing with a large scale of IO operations within high-speed devices and low-speed devices.</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/2067096/is-the-memory-alignment-different-for-different-data-types#2067244">https://stackoverflow.com/questions/2067096/is-the-memory-alignment-different-for-different-data-types#2067244</a></p>
</blockquote>
<p>So we use “BufferedReader” to deal with IO operations.</p>
<h3 id="Find-Out-the-Exact-Positions-of-Two-Values"><a href="#Find-Out-the-Exact-Positions-of-Two-Values" class="headerlink" title="Find Out the Exact Positions of Two Values"></a><strong>Find Out the Exact Positions of Two Values</strong></h3><h4 id="Fully-Sort-is-Costly"><a href="#Fully-Sort-is-Costly" class="headerlink" title="Fully Sort is Costly"></a><strong>Fully Sort is Costly</strong></h4><p>The intuition of me is to sort the whole sequence. However, when we notice that the whole set has a large scale of numbers (up to 10000), while all we need is to determine two exact positions for two certain values, we can find that our intuition is somehow costly. </p>
<p>But this can also serve as a booster of some inspiring ideas. For example, if I enlarge the objective values scale and reduce the dummy values scale, with the concentration of useful values increasing, of what extent will the original full sorting method “have some profits over other magic methods”? I will dive into some depth on it at future exploration part.</p>
<h4 id="Bucket-Sort-Can-be-Ruined-by-Sparse-Sequence-or-Big-h-Value"><a href="#Bucket-Sort-Can-be-Ruined-by-Sparse-Sequence-or-Big-h-Value" class="headerlink" title="Bucket Sort Can be Ruined by Sparse Sequence or Big h Value"></a><strong>Bucket Sort Can be Ruined by Sparse Sequence or Big h Value</strong></h4><p>Now we focus on methods with no fully sorting operations. Some intuitions dawn on me that there can be some monitors inside, for example a counter, to watch and check whether a situation is a symbol of finishing all work and beginning to purely work on trash. If so, then we can call an end to this function and save some effort. </p>
<p>So I come up with the “Partly” bucket sort method simultaneously. We create buckets on the way we visit the whole sequence, with a counter of elements number counting all elements that is smaller or bigger than the current one. If we manage it within two counters, then the cost will be very small!</p>
<p>However, as I test my program, I find that it can only perform well in the case when h value is small and the values have a dense distribution. It goes almost annoying when dealing with sparse sequence, and it has no privilege against original sorting methods when h value is big.</p>
<h4 id="Quick-Sort-Privilege-on-Partition-and-Scale-Decreasing"><a href="#Quick-Sort-Privilege-on-Partition-and-Scale-Decreasing" class="headerlink" title="Quick Sort Privilege on Partition and Scale Decreasing"></a><strong>Quick Sort Privilege on Partition and Scale Decreasing</strong></h4><p>Quick sort is not my original intension where I will have a try, the key factor that quick sort can fantastically tackle this problem is the partition operation which quick sort relies on. Partition is a good way for those cases that need to maintain “some extent of order” without paying most more effort. The order of it is relevant to some typical values, like binary trees. </p>
<p>In this cases, because the objective values are only two, so at the beginning of the procedure it may seem like a normal random function which pick all things without any partiality.  But as it cut off a good half of sequence every time it is placed, the speed to locate the objective value within a short interval will be tremendous, which can approach an exponential function with base 2.(Imagine!)</p>
<h3 id="Varify-a-Prime-Number"><a href="#Varify-a-Prime-Number" class="headerlink" title="Varify a Prime Number"></a><strong>Varify a Prime Number</strong></h3><h4 id="Primitives-Prime-Number-Distributions"><a href="#Primitives-Prime-Number-Distributions" class="headerlink" title="Primitives: Prime Number Distributions"></a>Primitives: Prime Number Distributions</h4><p>Mathematic nerds are born to be enthusiastic on magic numbers. I myself am nothing of them, but I am taught to know that prime numbers have a mysterious distribution on natural domains. A great Mathematic scholar, Riemann, established his Riemann Hypothesis that “very likely the distribution of prime numbers will be related with non-trivial zeros of Riemann zeta function”.</p>
<blockquote>
<p><em><a href="https://medium.com/cantors-paradise/the-riemann-hypothesis-explained-fa01c1f75d3f">https://medium.com/cantors-paradise/the-riemann-hypothesis-explained-fa01c1f75d3f</a></em></p>
</blockquote>
<p>I am nothing of a math guy, but it dawned on me that this theorem might be very useful when scientists are going to seek prime numbers among huge prime numbers. It can reduce a lot of dummy calculations on non-suspicious numbers.</p>
<p>The reason I say that much is to give you a context of prime numbers and it will be better for me to deliver my whole cargo. We can note from previous paragraphs and some related material that since prime numbers are getting<br>more and more sparse when its amount goes immense, and as it has a distribution of this shape, we can apply a powerful method “sieve of Eratosthenes” to it.</p>
<blockquote>
<p><em><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a></em></p>
</blockquote>
<p>(Please be careful with the prime numbers distribution! I know it is an intuition for people to think that “Because some small prime numbers can be the factor of big numbers, which can play a role as the big ‘<br>traitor’ when a big number is going on its canonization prime-wise.” Like this guy on quora. This is a very ambiguous mistake for scholars! I know you all have been highly educated and had much more insights than me, but this was truly a illusion for all of us. This is NOT the REASON for the prime numbers getting scarce! We can use this as a method for further estimation and analysis, but it is not THE REASON!)</p>
<h4 id="Application-Sieve-of-Eratosthenes"><a href="#Application-Sieve-of-Eratosthenes" class="headerlink" title="Application: Sieve of Eratosthenes"></a><strong>Application: Sieve of Eratosthenes</strong></h4><blockquote>
<p><em>The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime.[1] This is the sieve’s key distinction from using trial division to sequentially test each candidate number for divisibility by each prime.</em></p>
</blockquote>
<p>I think it is none other than all the essence inside this filter. I will not waste any breathe on further elaborations. This is only one of those trivial jugglery that mathematics shows her patronization to poor men.</p>
<h2 id="Further-Explorations"><a href="#Further-Explorations" class="headerlink" title="Further Explorations"></a><strong>Further Explorations</strong></h2><h3 id="What-if-the-Data-Scale-is-not-Static"><a href="#What-if-the-Data-Scale-is-not-Static" class="headerlink" title="What if the Data Scale is not Static?"></a><strong>What if the Data Scale is not Static?</strong></h3><p>This thought comes from a feature of BufferedReader, which shown below:</p>
<blockquote>
<p><em>“BufferedReader is synchronous while Scanner is not. BufferedReader should be used if we are working with multiple threads.”</em></p>
</blockquote>
<blockquote>
<p><em><a href="https://www.geeksforgeeks.org/difference-between-scanner-and-bufferreader-class-in-java/">https://www.geeksforgeeks.org/difference-between-scanner-and-bufferreader-class-in-java/</a></em></p>
</blockquote>
<p>As I know that BufferReader is synchronous and can be used to cope with multiple threads business, I doubt that whether it can be used to perform online processing. This is a much more complicated case since the dataset is engulfing in all the time. Can it do this job? if yes, how can / do BufferReader deal with their competitions?</p>
<h3 id="Of-What-Extent-will-Full-Sorting-Method-“have-some-profits-over-other-magic-methods”"><a href="#Of-What-Extent-will-Full-Sorting-Method-“have-some-profits-over-other-magic-methods”" class="headerlink" title="Of What Extent will Full Sorting Method “have some profits over other magic methods”?"></a><strong>Of What Extent will Full Sorting Method “have some profits over other magic methods”?</strong></h3><p>I view this question on a strange perspective. Full sorting method can be regarded as every number takes up its own occupation correctly. But partly sorting method can be regarded as make some members take their correct places, and make some members take the wrong places.<br>As we can know that other values individually make no difference on objective numbers on partly sorting, but some groups may make some difference, for instance, if I want to find 4th largest number, then we have to manage that finally three numbers standing previously to the 4th largest number, but these three member can also switch their relevant positions, so it will generate 6 cases, that is to say, if a method of any kind, cannot deal with any n people’s permulations standing behind an object within ∑n! steps, and then every sorting method can beat it. I now can only have limited ideas on this topic. I might further continue on it by consulting people or myself.</p>
<h2 id="My-Codes"><a href="#My-Codes" class="headerlink" title="My Codes"></a><strong>My Codes</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 启动时在程序第一行输入jc, 即可进入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// i for (inclusive), e for exclusive</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getKHT()&#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] arr_headkh = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">while</span> (k==<span class="number">0</span> || h==<span class="number">0</span>)&#123; <span class="comment">// k, h 0(e)</span></span><br><span class="line">		Random r1 = <span class="keyword">new</span> Random(<span class="number">1000</span>);</span><br><span class="line">		Random r2 = <span class="keyword">new</span> Random(<span class="number">2000</span>);		</span><br><span class="line">		k=r1.nextInt((<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, <span class="number">4</span>)+<span class="number">1</span>);<span class="comment">// k: 0(i) to 10**4(i)</span></span><br><span class="line">		h=r2.nextInt(k+<span class="number">1</span>);<span class="comment">// h: 0(i) to k(i)</span></span><br><span class="line">		arr_headkh = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">2</span>]; <span class="comment">// 头部是kh</span></span><br><span class="line">		&#125;</span><br><span class="line">		arr_headkh[<span class="number">0</span>]=k;</span><br><span class="line">		arr_headkh[<span class="number">1</span>]=h;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k+<span class="number">2</span>;i++)&#123; <span class="comment">// 开头占了2人, 结尾就空出两个位子</span></span><br><span class="line">			Random ri=<span class="keyword">new</span> Random(<span class="number">2001</span>+i); <span class="comment">// prevent same seeds</span></span><br><span class="line">			arr_headkh[i]=ri.nextInt(Integer.MAX_VALUE); <span class="comment">// 0(i) to Integer.MAX_VALUE(i)</span></span><br><span class="line">			<span class="comment">//https://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt%28int%29</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr_headkh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AS1Codes_117010155</span> <span class="keyword">extends</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//	private static int[] arr;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHthMin</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> h, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (low&gt;high) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i,j,temp,minResult;</span><br><span class="line">		i=low;</span><br><span class="line">		j=high;</span><br><span class="line">		<span class="keyword">int</span> pivot=arr[low];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">			<span class="keyword">while</span>(pivot&lt;=arr[j] &amp;&amp; i&lt;j) &#123;</span><br><span class="line">				j-=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (pivot&gt;=arr[i] &amp;&amp; i&lt;j) &#123;</span><br><span class="line">				i+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">				temp=arr[j];</span><br><span class="line">				arr[j]=arr[i];</span><br><span class="line">				arr[i]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[low]=arr[i];</span><br><span class="line">		arr[i]=pivot;</span><br><span class="line">		<span class="keyword">if</span> (i==h-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> arr[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i&lt;h-<span class="number">1</span>) &#123;</span><br><span class="line">			minResult=getHthMin(arr, h, i+<span class="number">1</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			minResult=getHthMin(arr,h,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minResult;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;=<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;=<span class="number">3</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span> || n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> sqrt_n=(<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">5</span>; i&lt;=sqrt_n;i=i+<span class="number">6</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span> || n%(i+<span class="number">2</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Driver program to test above methods  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    	BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    	String str1=<span class="keyword">null</span>,str2=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		str1=br.readLine();</span><br><span class="line">    		str2=br.readLine();</span><br><span class="line">    	&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(str1!=<span class="keyword">null</span> &amp;&amp; !str1.equals(<span class="string">&quot;jc&quot;</span>)) &#123;</span><br><span class="line">    	String[] str1_list=str1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    	k=Integer.valueOf(str1_list[<span class="number">0</span>]);</span><br><span class="line">    	h=Integer.valueOf(str1_list[<span class="number">1</span>]);</span><br><span class="line">    	<span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    	<span class="keyword">if</span> (str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		String[] str2_list=str2.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">    			arr[i]=Integer.valueOf(str2_list[i]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	        <span class="keyword">int</span> h_small=getHthMin(arr, h, <span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">	        <span class="keyword">int</span> h_large=getHthMin(arr, k-h-<span class="number">1</span>, <span class="number">0</span>, k-<span class="number">1</span>); <span class="comment">// 4个元素来看, 第2大就是第3小.因此h+x=length-1</span></span><br><span class="line">	        <span class="keyword">int</span> m=h_large-h_small;</span><br><span class="line">	        <span class="keyword">boolean</span> primeOrNot=isPrime(Math.abs(m));</span><br><span class="line">	        <span class="keyword">if</span> (primeOrNot)</span><br><span class="line">	        	System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	        <span class="keyword">else</span></span><br><span class="line">	        	System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	        System.out.println(m);</span><br><span class="line">	    &#125; 	</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(str1.equals(<span class="string">&quot;jc&quot;</span>))&#123;<span class="comment">// jc=jiancha</span></span><br><span class="line">			System.out.println(str1);</span><br><span class="line">			<span class="keyword">int</span>[] kht=getKHT();</span><br><span class="line">			k=kht[<span class="number">0</span>];</span><br><span class="line">			h=kht[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span>[] arr=Arrays.copyOfRange(kht,<span class="number">2</span>,kht.length);</span><br><span class="line">	        <span class="keyword">int</span> h_small=getHthMin(arr, h, <span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">	        <span class="keyword">int</span> h_large=getHthMin(arr, k-h-<span class="number">1</span>, <span class="number">0</span>, k-<span class="number">1</span>); <span class="comment">// 4个元素来看, 第2大就是第3小.因此h-x=length-1</span></span><br><span class="line">	        <span class="keyword">int</span> m=h_large-h_small;</span><br><span class="line">	        <span class="keyword">boolean</span> primeOrNot=isPrime(Math.abs(m));</span><br><span class="line">	        <span class="keyword">if</span> (primeOrNot)</span><br><span class="line">	        	System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	        <span class="keyword">else</span></span><br><span class="line">	        	System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	        System.out.println(m);</span><br><span class="line">	    &#125; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>截图网址两手抓-hexo代码一键复制</title>
    <url>/58452/</url>
    <content><![CDATA[<p>发现知乎的回答许多被删除了,此时纵使拿着网址也无法访问这些资源,可见仅仅保存网址是不安全的,毕竟删除网站的主动权不在我方手中.<br>知乎有位义士提供了”截图”这个办法<a href="https://zhuanlan.zhihu.com/p/31080308">蛏子圣子</a>,可谓大道至简.<br>今后任何的博客教程和网站信息, 我都会立刻进行截图保存,做到”截图”和”网址”的两手抓.</p>
<ul>
<li>hexo next代码块一键复制教程如下:<ul>
<li>感谢小哥<a href="https://www.jianshu.com/p/3e9d614c1e77">恬雅过客</a>的帮助.</li>
<li>使用fast stone capture进行博文滚动截图, 截图如下: (利用前文中的”标签插件语法”)<ul>
<li><img src="/58452/hexo%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6.jpg" class="" title="hexoNext代码块一键复制功能">


</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>警示:<ul>
<li>每次对”环境文件”进行内部修改的时候,一定要有两个意识<ul>
<li>替身意识: 对象文件副本创建与备份</li>
<li>独立化意识: 保存”修改前后”到一个独立文件中, 例如, {修改前(2019年8月14日11:21:07):{…}; 修改代码为{…}.}, 理由是:<ul>
<li>防备后患: 替身只能防止当前的出错, 但是有的问题是很久后才会暴露的</li>
<li>便于移植: 其他电脑有相似需求, 可以立刻移植</li>
<li>版本控制: ^举例^ <ul>
<li>做过3次修改, 现在报错是哪一次导致的呢? 我们就可以根据这个独立的文件进行观察&amp;有序进行版本回退.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>上传特定类型文件</tag>
      </tags>
  </entry>
  <entry>
    <title>打字训练</title>
    <url>/23677/</url>
    <content><![CDATA[<p>以前没有使用标准指法, 导致打字速度无法提升. 由于近期较为清闲, 于是开始着手练习打字, 一是为了日后代码能够勤写注释, 二是为了考托福.</p>
<p>训练网站: <a href="https://www.keybr.com/">keybr.com</a>; 感谢知乎小伙伴<a href="https://www.zhihu.com/question/25009442/answer/29795905">@何明涛</a>;</p>
<p>器材: 买了一副18.9元的Dell 8175薄膜键盘, 没有使用鼓吹的机械键盘,原因一是认识上觉得机械键盘有些浪费, 二来是心理上对入坑的本能恐惧, 面对诱惑我向来不能很好的抵制, 因此就干脆不要面对的好; 实际上, 这款键盘的手感非常不错, 加上tickeys的键盘声效几可乱真.可见伪物也是可贵的,伪物也有伪物的魂.</p>
<p>训练情况: 目前仍然惨不忍睹, 见图:<img src="/images/%E6%89%93%E5%AD%97%E8%AE%AD%E7%BB%83.jpg" alt="image"></p>
]]></content>
      <tags>
        <tag>打字训练</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客[&quot;hexo g -d&quot; gitbash一键上传]</title>
    <url>/34312/</url>
    <content><![CDATA[<p>开始总是令人喜悦的吗? 不见得, 至少秋风画扇就是一个反例, 我们在一个平凡得有些搞笑的世界线上, 一天天朝着无限世俗和无尽丰满的地平线走去<br>我也想过回头, 但是绝路什么的依然会在前面等着我, 或者说没有退路也无妨的, 曾经被称作来路的地方, 现在已经凭空生成了断崖, 这样好像是悬崖在一路追赶着我们一样, 但是他的步子是温和而不疾不徐的, 像是跟着我们在走, 这样的想法使我凭空生出的领路人错觉, 作为余生的狂欢也显得情有可原, 走得远的人不一定都是很讲逻辑的, 然而也似乎无可指摘, 因了走得远, 也不过成为后继者的一点谈资而已, 像是挫了敌人的骨而洋洋洒洒的灰烬固然痛快, 然而在增肥作物的实用价值这种量化指标衡量下也是さい至极<br>所以, 要多做一点快乐而有知识分量的事, 要多做一点无私而行善积德的事情, 在福报与智慧的加护下, 慢慢走过一生<br>春宵苦短, 少女前进吧!</p>
<ul>
<li><p>时间: 2019年7月16日21:49:50</p>
</li>
<li><p>听的歌是: 龙与虎Christmas</p>
</li>
<li><p>状态: 喜欢的人一样也无, 喜欢的事纷至沓来, </p>
</li>
<li><p>これで良い</p>
</li>
<li><p>参考资料:</p>
<ol>
<li><a href="https://blog.csdn.net/qq_36759224/article/details/82121420">搭建博客 hexo g -d</a></li>
<li><a href="https://blog.csdn.net/qq_36759224/article/details/85420403">博客美化</a></li>
<li><a href="https://blog.csdn.net/qq_36759224/article/details/85010191">功能添加</a></li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>上传特定类型文件</tag>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者习惯养成</title>
    <url>/37979/</url>
    <content><![CDATA[<ul>
<li>缘起<ul>
<li>办理移动业务时, 通过往日流水发现自己每月账单是88元,多花了不少冤枉钱.</li>
<li>办理移动业务途中, 使用百度地图搜索营业厅, 到目的地后才发现没有开门.</li>
<li>办理移动业务时, 产生”一体化”想法</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title>设备使用细节 &amp; 细碎日常 &amp; 新版</title>
    <url>/14256/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><ul>
<li>考察”日常”时发现一些问题, 这个新版主要是想解决这些问题才设置的.</li>
</ul>
<h1 id="以前存在哪些问题"><a href="#以前存在哪些问题" class="headerlink" title="以前存在哪些问题"></a>以前存在哪些问题</h1><ol>
<li>没有合适的归档整理, 导致混乱</li>
<li>内容在”技术”层面的纯度不足, 混杂了一些感想这种东西, 导致鱼龙混杂, 不好寻找(我个人不偏向鱼龙任何一方, 讨厌的对象只是混杂本身)</li>
</ol>
<h1 id="归档的协议"><a href="#归档的协议" class="headerlink" title="归档的协议"></a>归档的协议</h1><ol>
<li>每个月份更新下<code>##</code>小标题, 搜狗输入法输入ny(有教程自定义一下)</li>
<li>每天更新下<code>###</code>小标题, 搜狗输入法输入nyr(以后注意下, ny和nyr就是”年月”和”年月日”, 注释不能更新, 坑爹!)</li>
</ol>
<h1 id="记录什么内容"><a href="#记录什么内容" class="headerlink" title="记录什么内容"></a>记录什么内容</h1><ol>
<li>技术相关的问题&amp;思考&amp;解决方案&amp;待解决问题</li>
<li>复杂的配置过程&amp;注意事项</li>
<li>学习进程中自然产生的一些灵感or思索</li>
</ol>
<h1 id="不记录什么内容"><a href="#不记录什么内容" class="headerlink" title="不记录什么内容"></a>不记录什么内容</h1><ol>
<li>日常对人生&amp;对哲学的思考, 这些转移到日记中去, 避免污染</li>
<li>日常的心情和感受, 同样的理由, 同样的去处</li>
<li>对事件巧妙的处理办法(例如”更换时钟”一事), 主要是这些巧妙的处理办法与计算机技术无关, 也是转移到日记中去避免污染</li>
</ol>
<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><ol>
<li>对”解决方案”的正确性质疑: 这个”新版”不意味着就比旧版好多少, 以后还会有”新新版”等等的版本号的.</li>
<li>以后版本号多了就约定为: 使用π的近似值作为版本号显示工具(没错我就是抄Knuth怎么的了…)</li>
</ol>
<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><h2 id="2019年10月"><a href="#2019年10月" class="headerlink" title="2019年10月"></a>2019年10月</h2><h3 id="2019年10月19日"><a href="#2019年10月19日" class="headerlink" title="2019年10月19日"></a>2019年10月19日</h3><ul>
<li>(2019年10月19日19:24:18) 侯捷《C++标准函数库》的讲座真的赞! 直接B站搜”侯捷”即可, 真是大师风范, 他的讲课真正展示了什么是”微言大义”, 点这里<a href="https://www.bilibili.com/video/av45108908?from=search&seid=18304083379144917647">侯捷C++-从平地到万丈高楼</a>, 或者B站直接搜”侯捷”也可以!</li>
<li><del>(2019年10月19日19:46:49) 这个toc好像一旦使用1.2.3这样的标签还没法在网页上显示了, 必须使用短横线<code>-</code>变成无序列表才能显示, 屑!</del></li>
<li>(2019年10月19日19:56:38) 无法显示标签的原因是使用了encrypt插件的缘故, 他智能隐藏了toc的东西…去除掉password字段即可…</li>
<li>(2019年10月19日19:58:27) 每次要更改hexo设置的时候, 第一步先hexo s看一看会生成什么, 最后再hexo g -d, 因为上传是有延时的, 这样就不如hexo s来得及时有效<h3 id="2019年10月22日"><a href="#2019年10月22日" class="headerlink" title="2019年10月22日"></a>2019年10月22日</h3></li>
<li><a href="https://zh.cppreference.com/w/cpp/language/operator_precedence">C++运算符-优先级-结合性</a></li>
<li><a href="https://zh.cppreference.com/w/c/language/operator_precedence">C运算符-优先级-结合性</a></li>
<li>这两篇写得太好了, 我就觉得优先级与结合性必须绑定起来综合考虑</li>
<li>TCPL我要吹一辈子, 为什么我没有提前看到这本书, 我觉得真的算得上”微言大义”的典范了, 嗯~</li>
<li><a href="https://en.cppreference.com/w/c/language/array_initialization">init-arrays</a></li>
<li>配置Clang编译器, 因为主页<a href="https://www.zhihu.com/question/351744551/answer/865665382">千里冰封</a>的推荐, 所以我去安装了试试, 以下是简要记录(我的运气还是挺好的, 至少没有看到一些劝退的帖子, 安装过程算是非常顺利的一次了…)</li>
</ul>
<ol>
<li>根据<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">这里</a>我们知道一共有3件事要做, {安装mingw64和msys2}-{在msys2中安装llvm和clang}-{在clion中配置cmake和toolchain选项}</li>
<li>安装mingw64和msys2不用提了…</li>
<li>在msys2中安装llvm和clang, 都懂得, 只要一涉及这种命令行下载东西的时候, 就立马先到网上查一下”换源”什么的, 于是搜索”msys2 换源”, 然后在<a href="https://mirror.tuna.tsinghua.edu.cn/help/msys2/">这里</a>找到了答案, 这就是一种意识, 很多时候应该变成一种条件反射的东西, 哦一旦出现命令行下载东西就立马换源换源…如果不是命令行的话呢, 就请买一个IDM, 你会发现你后半生的下载会非常自在的…</li>
<li>clion中的配置过程, 首先按照<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206606735-Using-Clang-With-CLion-on-Windows?page=1#community_comment_115000631284">原网页</a>上面显示的配置cmake选项的确是OK的, 那个CC={sth1}, CXX={sth2}一看就知道是环境变量里面的键值对, 所以直接将CC和CXX配置到环境变量里头去即可, 但并没有结束, 此处没有考虑到toolchain的情况, 下面是toolchain的配置.</li>
<li>根据<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000394670-How-can-I-configure-LLVM-Clang-6-0-with-CLION-2018-1">这里</a>我们找到这段话<code>You can&#39;t use clang in CLion on Windows without having MinGW or Cygwin installed. You can try the following:</code>, 说明我们还是要把mingw放在Environment下, 只是make的工具全部换成clang系列的即可 (还有就是能让clion自己detect就不必手动加入绝对路径了…), 这里不多废话, 一图胜千言</li>
<li>第5步图</li>
</ol>
<ul>
<li><img src="/14256/clion_clang%E9%85%8D%E7%BD%AE_toolchain_mingw%E9%83%A8%E5%88%86.jpg" class="" title="clion_clang配置_toolchain_mingw部分"></li>
<li><img src="/14256/clion_clang%E9%85%8D%E7%BD%AE_toolchain_clang%E9%83%A8%E5%88%86.jpg" class="" title="clion_clang配置_toolchain_mingw部分"></li>
</ul>
<ol start="7">
<li>成果是这样的</li>
</ol>
<ul>
<li><img src="/14256/clang%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.jpg" class="" title="clang报错信息"></li>
<li>下次试着把cl.exe也安装上去, 看看每家编译器的水准如何hh~<h3 id="2019年10月31日"><a href="#2019年10月31日" class="headerlink" title="2019年10月31日"></a>2019年10月31日</h3></li>
<li>(2019年10月31日18:31:37) 这几天工作量之大真是令人发指!</li>
<li>(2019年10月31日18:31:55) 突然之间发现email里面存了大量不看的twitter消息, 感到有点愤怒, 一来是推特污染我的timeline, 二是我竟然一直是这样后知后觉的状态, 感觉很不应该!</li>
</ul>
<ol>
<li>根据<a href="https://www.zhihu.com/question/35809873">这里</a>得知大致的办法, 注意, 我们必须从twitter网站本身入手, 而不是更改mail的规则, 因为问题的本身出在twitter身上, 我们要从本源下手.</li>
<li>从<a href="https://twitter.com/settings/notifications">settings-notifications</a>这边点进去, 找到”email_notifications”字样, 然后把它取消掉, 大功告成!</li>
</ol>
<ul>
<li>(2019年10月31日18:36:31) 推广一下, 我们注意到偶尔github也会给我发这样的邮件, 所以出于防备, github的邮件我也设置一下拒收~</li>
</ul>
<ol>
<li>首先, 网站的api往往是一样的, 于是猜一波<code>settings/notifications</code>, 我真机智, 点<a href="https://github.com/settings/notifications">这里</a></li>
<li>因为我自己是一个无名小卒, 一般没有人会at我, 所以我把全部的更新都关闭掉~见如下图示</li>
<li><img src="/14256/%E9%80%80%E8%AE%A2github%E9%82%AE%E4%BB%B6.jpg" class="" title="退订github邮件"></li>
</ol>
<ul>
<li>(2019年10月31日18:33:01) 页表的概念理解错了一处, 感谢陈靖一大佬及时指出, 很多时候我都是自己吓死自己, 其实难度一点也不大, 只是我有一处搞错了, 然后后面就莫名变得无比艰难, 关键是我自己意识不到, 唉~</li>
<li>(2019年10月31日19:28:37) setupvpn插件有几个问题</li>
</ul>
<ol>
<li>有时候连接不上vpn</li>
<li>有的时候连接上vpn后, 点击图标响应时间很长</li>
<li>所以很多时候if连不上(断网重新点击连接); if关不掉, 直接退出浏览器窗口重开一个, 反正winr也很快</li>
</ol>
<ul>
<li>(2019年10月31日19:33:43) 根据<a href="https://stackoverflow.com/questions/27768308/linux-shell-scripting-using-alias-in-a-function#27768471">这里</a>, 我们知道加一行<code>shopt -s expand_aliases</code>就可以使得function里面直接使用alias了! 酷炫! 当然, 这里有几点注意:</li>
</ul>
<ol>
<li>bash里面所有的命令基本都可以看成全局的, 写在函数里面的命令, 也是对全局作用域有效的!如图所示:<img src="/14256/bash_%E4%B8%80%E5%BE%8B%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" class="" title="bash_一律全局作用域"></li>
<li>不希望继续使用expanded_aliases的话, 使用这个命令<code>shopt -u expand_aliases</code>(s for set, u for unset)</li>
<li>已经封装成函数<code>sea</code>和<code>usea</code>(<code>set expanded alias</code> and <code>unset expanded alias</code>)</li>
<li><del>如果不希望污染的话, 就在函数开始前用一下sea(); 结束前用一下usea()即可</del></li>
<li>上面说法有误, 因为一旦调用就是全局性的效果, 所以建议默认用sea(), 直到某个函数会有冲突时再使用usea()</li>
</ol>
<h3 id="2019年11月1日"><a href="#2019年11月1日" class="headerlink" title="2019年11月1日"></a>2019年11月1日</h3><h3 id="2019年11月20日"><a href="#2019年11月20日" class="headerlink" title="2019年11月20日"></a>2019年11月20日</h3><ul>
<li>(2019年11月20日15:10:10) <a href="https://blog.csdn.net/Adam_allen/article/details/78997709">解决github上传速度慢的动态办法</a></li>
<li><img src="/14256/%E5%8A%A8%E6%80%81%E6%80%9D%E8%B7%AF-%E8%A7%A3%E5%86%B3github%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E6%85%A2.jpg" class="" title="动态思路-解决github访问速度慢"></li>
<li>(2019年11月20日15:11:45) 接上一条,ttl数值越大表示网速越快…</li>
<li>(2019年11月20日15:17:44) <a href="https://blog.csdn.net/qq_33404395/article/details/80263709">github大于100M文件上传</a><h3 id="2019年11月21日"><a href="#2019年11月21日" class="headerlink" title="2019年11月21日"></a>2019年11月21日</h3></li>
<li>(2019年11月21日22:30:28) 几个今生可能会去实现的目标:</li>
</ul>
<ol>
<li>做公益活动,使人们意识到他人的痛苦</li>
<li>修改大量计算机中文版教材,减少不通顺的地方</li>
</ol>
<h3 id="2020年1月13日"><a href="#2020年1月13日" class="headerlink" title="2020年1月13日"></a>2020年1月13日</h3><ul>
<li>(2020年1月13日00:54:20) 又回来了, 上个学期真是人生的梦魇呢…</li>
</ul>
<ol>
<li>shareX的OCR功能非常强大, 尤其是他的截屏OCR功能! 我的两篇文章4-5千字只有图片信息保存, 就是借助他的准确识别才得以避免大篇幅的修改</li>
<li>发现了Onedrive的”释放空间”的功能, 我的空间又足够装下一个Ubuntu了, 于是马上就装起来…</li>
<li>最近想到死的次数已经减少了一些, 主要是忙了起来, 唉感觉我的一生真是乱七八糟的, 一没动力闲下来就想着写诗, 写文章, 然后就无限感觉人生没有半点希望还不如早些结束…唉~</li>
</ol>
]]></content>
      <tags>
        <tag>碎片信息集散</tag>
        <tag>长期更新</tag>
      </tags>
  </entry>
  <entry>
    <title>往期博客链接</title>
    <url>/links/</url>
    <content><![CDATA[<p>原先只是在 _config.yml 里面单开一个 links 字段来写所有链接，但这个字段是属于 blog rolls 的，而 blog rolls 在手机上看不了，必须要在 menu 字段下的才会在手机上显示，现在把它弄成单独的 links 页面并统合到 menu 字段下，这样手机用户就能够查看这些链接了。</p>
<p>Linkeer365: <a href="https://linkeer365.github.io/">https://linkeer365.github.io/</a><br>Linkeer365ColorfulLife: <a href="http://linkeer365.github.io/Linkeer365ColorfulLife">http://linkeer365.github.io/Linkeer365ColorfulLife</a><br>Linkeer365ColorfulLife2: <a href="http://linkeer365.github.io/Linkeer365ColorfulLife2">http://linkeer365.github.io/Linkeer365ColorfulLife2</a><br>Linkeer365ColorfulLife3: <a href="http://linkeer365.github.io/Linkeer365ColorfulLife3">http://linkeer365.github.io/Linkeer365ColorfulLife3</a><br>Linkeer365TinyMoment: <a href="https://linkeer365.github.io/Linkeer365TinyMoment">https://linkeer365.github.io/Linkeer365TinyMoment</a><br>Linkeer365TinyMoment2: <a href="https://linkeer365.github.io/Linkeer365TinyMoment2">https://linkeer365.github.io/Linkeer365TinyMoment2</a><br>Linkeer365BookReview: <a href="https://linkeer365.github.io/Linkeer365BookReview">https://linkeer365.github.io/Linkeer365BookReview</a></p>
]]></content>
  </entry>
  <entry>
    <title>设备使用细节 &amp; 细碎日常</title>
    <url>/22400/</url>
    <content><![CDATA[<h1 id="DetailsOnWindowsUsage"><a href="#DetailsOnWindowsUsage" class="headerlink" title="DetailsOnWindowsUsage"></a>DetailsOnWindowsUsage</h1><h2 id="报错-amp-警告-amp-心得体会-原因分析-amp-解决办法-amp-经验总结"><a href="#报错-amp-警告-amp-心得体会-原因分析-amp-解决办法-amp-经验总结" class="headerlink" title="报错&amp;警告&amp;心得体会-原因分析&amp;解决办法&amp;经验总结"></a>报错&amp;警告&amp;心得体会-原因分析&amp;解决办法&amp;经验总结</h2><h2 id="长期更新-当前时间是2019年6月15日10-11-36"><a href="#长期更新-当前时间是2019年6月15日10-11-36" class="headerlink" title="长期更新, 当前时间是2019年6月15日10:11:36"></a>长期更新, 当前时间是2019年6月15日10:11:36</h2><h2 id="现在停止更新-于2019年10月19日19-05-52转移至”新版”"><a href="#现在停止更新-于2019年10月19日19-05-52转移至”新版”" class="headerlink" title="现在停止更新, 于2019年10月19日19:05:52转移至”新版”"></a>现在停止更新, 于2019年10月19日19:05:52转移至”新版”</h2><ul>
<li><p>操作无法完成因为文件已在{?}另一程序中打开// 其他文件夹中打开</p>
<ul>
<li>解决办法: 任务管理器-性能-资源监视器-CPU-关联的句柄搜索框-[输入文件名/文件夹名]-结束列出的所有任务</li>
</ul>
</li>
<li><p>PC端微信的”设置”,”备份”功能</p>
<ul>
<li>设置: <ol>
<li>设置-通用设置-[我是只保留了: 1. 保留聊天记录; 2. 适配比例; 3. 使用默认浏览器打开网页]</li>
<li>设置-[在备份完成后]-清空聊天记录</li>
</ol>
</li>
<li>备份: [每个星期]备份至电脑</li>
<li>Android微信客户端: [进入”我-设置”]<ol>
<li>聊天-聊天记录备份与迁移-清空聊天记录</li>
<li>通用-字体大小-最小</li>
<li>通用-照片视频与文件-全部关闭</li>
<li>通用-发现页管理-只保留”朋友圈”+”小程序”</li>
<li>通用-横屏模式+NFC功能-关闭</li>
</ol>
</li>
</ul>
</li>
<li><p>Jupyter notebook 快捷方式</p>
<ul>
<li>目标是: 1. work_dir换成D:/jupyter notebook 2. 用conda命令行输入jn打开jupyter notebook[此时其work_dir是在D:/jupyter notebook]</li>
<li>解决方法:<ol>
<li>conda输入jupyter notebook –generate-config, 找到jupyter_notebook_config.py, 查找c.NotebookApp.notebook_dir, 填写保存</li>
<li>[改名] 利用<a href="https://stackoverflow.com/questions/20530996/aliases-in-windows-command-prompt%E4%B8%8B%E7%9A%84Velixo%E7%9A%84%E5%8A%9E%E6%B3%95">https://stackoverflow.com/questions/20530996/aliases-in-windows-command-prompt下的Velixo的办法</a>, 创建文件夹D:/aliases, 里面写一个jn.bat, 内容是: # jn就是你的aliase<ul>
<li>@echo off</li>
<li>echo.</li>
<li>jupyter notebook %*</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>换行, 回车是两个不同的概念!</p>
<ul>
<li>换行: \n -&gt; newline; 表示光标下移一行[不一定在行首]</li>
<li>回车: \r -&gt; return; 表示光标回到开头字符处; [就有的时候没有换行就直接回车 可能会覆盖掉之前的字符吧估计]</li>
</ul>
</li>
<li><p>java定义数组风格是: datatype[] arrayrefvar; C++/C定义数组风格是: datatype arrayrefvar[]; </p>
</li>
<li><p>pycharm的project interpretr 安装包时nothing to show: 第三个按钮刷新一下</p>
</li>
<li><p>单行速度查询: profiling</p>
</li>
<li><p>(2019年8月26日11:04:59)百度手机输入法做得很好:</p>
<ul>
<li>支持双拼</li>
<li>支持个性短语: <ul>
<li>(例如,输入 xx:香港中文大学深圳; xxdz:广东省深圳市龙岗区龙翔大道2001号)</li>
<li>电脑上搜狗输入法就可以自定义</li>
</ul>
</li>
<li>主界面上画输入符号,无需切换至符号界面: <ul>
<li>(例如,主界面QWERT各键向上滑动, 可以输入1,2,3,4的符号)</li>
<li>“上画”相当于按住”shift”键, 各个字母都有对应的shift映射</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年8月26日11:05:16) 知乎原生支持vim模式, 查看方式是主界面上输入?即可查询</p>
<ul>
<li>知乎vim和插件vimium有冲突, vimium记得屏蔽zhihu.com的页面</li>
</ul>
</li>
<li><p>(2019年8月26日11:12:14) 动车上无事可做, 于是整理下近期思路:</p>
<ul>
<li><p>哲学上蒯因对我的影响是比较大的, 语义溯游什么的还是比较适合基础薄弱的我.</p>
</li>
<li><p>博学而深刻的女人们, 很容易落入孤傲或咄咄逼人两个极端,且可悲的共同点在于从此便失去了容人的能力</p>
<ul>
<li><p>现状存在的问题:</p>
<ul>
<li>如此必天然地有害于人际与社交;</li>
<li>可是女人们对人际与社交的潜在需求又远高于男人们(我想问题主要出在无知的女人们只对人际社交感兴趣,而无知的女人在女性中占比又过高且容易团结,导致劣币驱逐良币这样)</li>
<li>优质女性类似”瘟神”被边缘化, 无知女性类似”大家闺秀”始终把控舆论高地, </li>
<li>新生代唯恐变成”瘟神”, 于是发育时知识的分化程序便严重受限</li>
</ul>
</li>
<li><p>当前多数女性关注哪些领域的内容? 为何不高级?</p>
<ul>
<li>哪些领域: (目前很多女性关注的领域, 很多是资本封装好的”奶头乐”, 比如美妆与衣饰服装, 或者是人际社交处理的技巧与训练, 例如追求如何与人交友, 如何建立异性友谊, 如何鉴别各种”绿茶婊”)</li>
<li>为何不高级: <ul>
<li>完事得太快:<ul>
<li>动机不纯: 多半缺乏真实的兴趣, 只是出于人设建立的需要, 例如对香水的研究, 只是为了让别人觉得她”有品位””有文化”, 打造好这样的人设后, 她就达到目的了. 这类人估计不懂”前调””后调”之类的术语.</li>
<li>不愿实践: 有一点兴趣的会看一些书, 胡乱记些”前调””后调”什么的专业名词, 这固然不错, 但是上手配置与勤品常鉴就差得远了. 碍于情面而不愿意提起大刀, 这样对香水之”魂”的品鉴肯定要下落一个档次的. 这类人基础不错, 但不会有靠得住的才华</li>
</ul>
</li>
<li>受制而固步: <ul>
<li>愿意实践,不畏艰辛, 这类人在女性中已近翘楚. 然而社会总不希望女人们专注于某个领域, 必以婚育相逼, 婚育出于进行时态的女性, 纵有心力之余, 社会也要来纠她的”偏”,宣称其”不务正业”; 倘不婚育, 又称为社会人眼里完美的反面教材, “太聪明就会孤独终老”云云已算客气, “偷期密约””性情乖僻而为人所弃”的毁谤又哪里会少得了!</li>
</ul>
</li>
<li>市场被攫取:有些领域是女性擅长的, 但是男人们看到有市场就抢占<ul>
<li>妇产科曾经有个叫”林巧稚”的神医, 在她的培养下,妇产科了一批精兵强将:由于只有女人在干这个活, 那时女医师们接生技术是非常牛逼的(就是成活率比现在低一点, 但是残障率显著低于目前), 但很快社会就发展出男性的妇产医师, 这潜在激发了女人们的畏难和依赖思想, 于是女医师们的技术又很快没落下去.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可行的建议:</p>
<ul>
<li>由此, 对”强化女智”的规划, 应该要从这群有知女性的”世俗化”着手,要让她们变成榜样而不是瘟神,这样新生代们才能好好发育大脑,长大后才会对一类高级领域感兴趣</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年8月28日18:36:33) 搜狗输入法打出复杂字体的功能:</p>
<ul>
<li>因为现在几乎都是拼音或者双拼打字, 这样一旦有一些不明白读音的字就会很尴尬.</li>
<li>打出复杂字体公式: (u+拆字片段), 举例:<ul>
<li>字形是三个’牛’ -&gt; “uniuniuniu” -&gt; 犇(ben1)</li>
<li>字形是四个’又’ -&gt; “uyouyouyouyou” -&gt; 叕(zhuo2,yi3,li4,jue2) </li>
<li>字形是’草字头’下面一个’朋’ -&gt; “ucaopeng” -&gt; 蒯(kuai3)</li>
</ul>
</li>
<li>这个是一个三年级小朋友教我的, 他用这招在”多音字查找比赛”中获得了冠军, 可见后生可畏.</li>
</ul>
</li>
<li><p>(2019年9月1日15:59:02)总结这两天和陆小川聊天的收获:</p>
<ul>
<li>vimium插件的exclude keys功能, 可以实现在特定网站下对特定按键的排除<ul>
<li>例如,知乎的JK可以定位到回答,/可以打开搜索框, 所以这些按键都可以exclude keys[exclude keys:<code>&quot;jko\&quot;</code>]</li>
</ul>
</li>
<li>按esc键实现”光标失焦”<ul>
<li>vimium关闭网页时按x, 但是如果光标在搜索框则不行, 按照vim的观点此时处于”插入模式”, 那么按esc可以从插入模式中返回, 于是就摆脱光标(光标的失焦), 此时按x即可关闭页面</li>
</ul>
</li>
<li>babun zsh的实现, 在zsh里面安装一个git就可以了</li>
<li>zsh主题可以”random”(^_^), 我个人最喜欢ys主题, 全面而简洁.</li>
</ul>
</li>
<li><p>(2019年9月2日03:07:57) 忙的很晚, 复现一个python课程表, 突然觉得没什么意义就换成excel数据透视表来呈现</p>
<ul>
<li>字段组:{课程名, 课程类型(Lec or Tut), 课程起始时间, 课程时长, 课程地点, 周几开课}</li>
<li>透视表细节:<ul>
<li>筛选: 课程类型</li>
<li>纵轴: <ul>
<li>课程名</li>
<li>课程地点</li>
</ul>
</li>
<li>横轴:<ul>
<li>周几开课</li>
<li>课程起始时间</li>
</ul>
</li>
<li>值<ul>
<li>课程时长(因为从时长可以推断出是Tut或者Lec)</li>
</ul>
</li>
</ul>
</li>
<li>呈现效果:<ul>
<li><img src="/22400/%E5%A4%A7%E4%B8%89-%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86-%E8%AF%BE%E7%A8%8B%E8%A1%A8.jpg" class="" title="excel数据透视课程表">
</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年9月2日03:19:24) 发现再次忘记”将图片拉伸为合适手机电脑桌面大小”的办法, 记一下:</p>
<ul>
<li>手机电脑桌面: (单位是pixiv像素)<ul>
<li>宽 * 长 = 1920p *1080p </li>
</ul>
</li>
<li>图片右键编辑, 点击”重置图片为合适大小”, 注意单位是像素</li>
<li>宽和长分别设置为1920, 1080, 完成. </li>
</ul>
</li>
<li><p>(2019年9月5日11:32:10) 近两日看Haskell, 很基础的东西都看得很困, 烦心!</p>
</li>
<li><p>(2019年9月5日11:33:21) 注意feedings需要定期查询, 确保每个social media动态显示数不超过5人.</p>
<ul>
<li>QQ批量屏蔽好友动态流程:<ul>
<li>(左上角头像)-(设置)-(隐私)-(好友动态权限设置)-(拖动…)-(不看他的动态)-(添加好友)-(等一等即会弹出群名称, 在群名称中批量加入)</li>
</ul>
</li>
<li>微信批量屏蔽好友<ul>
<li>(我)-(设置)-(隐私)-(不看他她)-(点击加号)-(从群里导入,或者你手动点击也可以)</li>
</ul>
</li>
<li>一句话, 我对朋友圈内诸位的人设竞赛已经疲惫了, 之前只不过因为疏于考虑, 殊不知他们蚕食了我多少的时光, 不管是看书写程序还是打游戏, 都是一种无端的浪费.</li>
<li>我只想做令自己真正感到开心的事情, 真正能感到”不空虚”,”不荒诞”的事情, 而不是大众娱乐, 包括在知乎与B站上也是这样的, 只使用搜索功能, 不可避免的推送需要及时清查, 避免feedings的污染.</li>
</ul>
</li>
<li><p>(2019年9月5日11:46:49) B站点兔英文名是”Is the order a rabbit?”说明其实”点”不是”来一点冰淇淋好了”的副词, 而是”点菜”的动词含义.但我真正感兴趣的实际是这个句式, 比如:</p>
<ul>
<li>Is the qualia a monad?</li>
<li>思路起源于这里:<ul>
<li>(现实世界里有monad吗?)[<a href="https://www.zhihu.com/question/343575629]">https://www.zhihu.com/question/343575629]</a></li>
<li>(紫色的qualia-Procyon豆瓣点评)[<a href="https://book.douban.com/review/6618099/]">https://book.douban.com/review/6618099/]</a></li>
</ul>
</li>
<li>我不知道他们的联系在何处, 因为目前的我既不懂monad, 也不懂qualia.只是好奇这之间是否存在内置的联系.</li>
</ul>
</li>
<li><p>(2019年9月6日22:48:09) 教程<a href="https://blog.csdn.net/lihangll/article/details/80516085">hexo-next主题下添加pdf文件</a></p>
<ul>
<li>注意: 不能像asset_img一样直接写图片名字, 必须给出完整网页路径</li>
<li>举例: <code>https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/Haskell%E5%85%A5%E9%97%A8-%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/HaskellHackageCheatSheet.pdf</code>类似这样的写法</li>
<li>显然前面这一串<code>https://github.com/Linkeer365/Linkeer365.github.io/tree/hexo/source/_posts/</code>不变, 自然想到把这串放在搜狗输入法的”个性短语”中了<ul>
<li>添加为”bkpdf”(“博客pdf”), 大功告成!</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年9月6日22:48:59) 搜狗输入法打箭头符号:</p>
<ul>
<li>(zuoxia5) -&gt; ↙</li>
<li>(youxia5) -&gt; ↘</li>
<li>(zuoshang5) -&gt; ↖</li>
<li>(youshang5) -&gt; ↗</li>
<li>(nan6) -&gt; ♂</li>
<li>(nv6) -&gt; ♀</li>
</ul>
</li>
<li><p>(2019年9月6日23:40:16) hexo-pdf插件有问题, 屑!</p>
</li>
<li><p>(2019年9月7日13:58:35) 观察到url里头如果有”#”可以定位到网页的特定位置, 特地搜了一下文章:</p>
<ul>
<li><a href="https://www.cnblogs.com/kaituorensheng/p/3776527.html">#定位<a>name锚点&amp;定位<div>id属性</a></li>
<li>name和id不用说了, 直接F12检查元素.</li>
<li>细节上的不同之处: 以<a href="https://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let">这个网址</a>为例<ul>
<li><a href="https://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let#8274846">定位name锚点-#8274846-网页会发光</a></li>
<li><a href="https://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let#answer-8274846">定位id属性-#answer8274846-网页不发光</a></li>
</ul>
</li>
<li>功能是: 如果网页很长, 直接定位到答案就显得很方便.</li>
</ul>
</li>
<li><p>(2019年9月7日14:58:52) 这几天存了不少好的网页, 存一下截图:</p>
<ul>
<li><img src="/22400/2019%E5%B9%B49%E6%9C%887%E6%97%A5-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE.jpg" class="" title="截图时间-2019年9月7日15:05:37">
</li>
</ul>
</li>
<li><p>(2019年9月7日16:12:32) 以前没注意过tab和空格的问题, 解决下:</p>
<ul>
<li>tab长度是跟具体编辑器相关的, 有时候对不齐就很烦.</li>
<li>这边一致规定一下: 不准键入实际的’\t’, 敲打tab键时默认输入4个空格, 这样就可以了</li>
<li>把所有编辑器都进行这样的配置.</li>
</ul>
</li>
<li><p>(2019年9月7日16:40:31) Vscode 设置缩进空格显示:(“editor.renderWhitespace”:”bounary”).</p>
</li>
<li><p>(2019年9月7日20:51:19) 发现一篇极好的回答, 对我此后的人生估计都大有帮助:</p>
<ul>
<li><a href="https://www.zhihu.com/question/36328468/answer/68011955">诚实的伪物-提问的办法</a></li>
<li>特地截了图:<ul>
<li><img src="/22400/%E8%AF%9A%E5%AE%9E%E7%9A%84%E4%BC%AA%E7%89%A9-%E6%8F%90%E9%97%AE%E7%9A%84%E5%8A%9E%E6%B3%95.jpg" class="" title="不仅仅是PLT编程, 对人生也很受用">
</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年9月7日20:59:34) 复制粘贴不起作用?(默认使用的是Shift+Insert的粘贴办法)</p>
<ul>
<li>点击音量键, 看看是不是Fn lock了</li>
<li>取消Fn lock即可</li>
</ul>
</li>
<li><p>(2019年9月7日21:00:51) 把引用图片代码<code>&#123;% asset_img  %&#125;</code>加入搜狗个性短语中, 取名为”ipic”(insert picture缩写)</p>
</li>
<li><p>(2019年9月8日12:07:40) 双拼连按两键表示相同的单个字母</p>
<ul>
<li>例如: 京阿尼 -&gt;<ul>
<li>阿 -&gt; ‘aa’</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年9月11日15:50:41) 福昕阅读器调节成夜间模式</p>
<ul>
<li>文件-偏好设置-访问-自定义颜色-黑底, 50度灰色(RGB=(128,128,128))</li>
<li>扫描版-不勾选”只更改颜色是黑白的内容”</li>
<li>文字版-勾选”只更改颜色是黑白的内容”</li>
</ul>
</li>
<li><p>(2019年9月11日15:54:46) <a href="https://userstyles.org/styles/147942/nightmode#headline">chrome浏览器夜间模式</a></p>
<ul>
<li>使用”Install style as userscript”(页面上搜索, 这个没法用#定位), 把这个插件安到油猴里头去</li>
</ul>
</li>
<li><p>(2019年9月11日19:45:39) 书签整理完成, 书签文件已上传至”2019年9月11日19:47:23chrome bookmarks”里面</p>
<ul>
<li><img src="/22400/Haskell-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE.jpg" class="" title="Haskell书签"></li>
<li>
</li>
</ul>
</li>
<li><p>(2019年9月11日21:51:59) 计算日期太TM厉害了, 这个公式:</p>
<ul>
<li><a href="https://blog.csdn.net/qq_40772692/article/details/80330346">ACM数论—-基姆拉尔森计算公式（今天计算星期几）</a></li>
<li>张淞在《haskell函数式编程入门》中使用了另一手, 也是妙手  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 类型改名, 可以起到&quot;声明参数&quot;的作用</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Weekday</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Year</span>  = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Month</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Day</span>   = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个week 指的是 (年,&quot;今年一共过了&quot;几天) -&gt; (星期几)</span></span><br><span class="line"><span class="comment">-- 这个算法太高深了吧!!</span></span><br><span class="line"><span class="title">week&#x27;</span> :: <span class="type">Year</span> -&gt; <span class="type">Day</span> -&gt; <span class="type">Weekday</span></span><br><span class="line"><span class="title">week&#x27;</span> y d   = <span class="keyword">let</span> y1 = y - <span class="number">1</span> <span class="keyword">in</span> <span class="comment">-- y1 换元节省括号^_^</span></span><br><span class="line">            (y1 + (div y1 <span class="number">4</span>) - (div y1 <span class="number">100</span>) + (div y1 <span class="number">400</span>) + d) `mod` <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
<li>这篇解释得很清楚:<a href="https://cloud.tencent.com/developer/article/1163165">细说基姆拉尔森日期公式</a></li>
</ul>
</li>
<li><p>(2019年9月11日22:08:10) 所有的语言都要收集许多cheatsheets, 最近整理时发现这一妙招, 以后再也不会忘记用法了.</p>
<ul>
<li>cheatsheet可以到专门的cheatsheet网站上找.</li>
<li>整理好的cheatsheet记得合并, 以后好在pdf内直接搜索.</li>
<li>cheatsheet没有覆盖的地方, 记得新建pdf进行补充.</li>
</ul>
</li>
<li><p>(2019年9月17日12:13:04) 记录一下最近几天的事情</p>
<ul>
<li>学会了用NFC功能去模拟校卡门禁卡以及E通卡</li>
<li>上课一位身材魁梧的老哥向我展示了IDEA的各种快捷键, 相当厉害, 到时候我要去专门整理一下Jetbrains的快捷键</li>
<li>google搜索某种技术可以直接: 技术名称+{“get started”,”cheatsheet”,”notes”,”tutorial”}</li>
<li>看了一些东方的二设, 对雾雨魔理沙的好感又增强了一些, 魔理沙的硬汉程度应该不输jo太郎</li>
</ul>
</li>
<li><p>(2019年9月17日15:44:17) 关注一下统筹意识, 我觉得统筹意识很多时候就是”先想再做”的一个习惯.</p>
<ul>
<li>定位到单个知乎回答的办法, 不需要用<code>#</code>进行定位, 只需要用内置Vimium定位到回答后回车即可.</li>
</ul>
</li>
<li><p>(2019年9月18日15:41:23) 今日笑点:</p>
<ul>
<li>“Because the C++ group wanted to make a language so complex and confusing they would ensure their extreme hourly rates a decade from now because they would be the only ones able to work on the software.. (snark snark).”</li>
<li>点<a href="https://stackoverflow.com/questions/10183185/before-a-variable-name-c">这里</a></li>
</ul>
</li>
<li><p>(2019年9月20日01:44:42) 神烦今天, 玩一把双指针出了4个WA, 带来的教训是:</p>
<ul>
<li>多用debug, 观察变量的”类型”</li>
<li>python赋值时注意看有没有逗号, 防止被当做元组解读了</li>
<li>双指针, 变量更新时机很关键</li>
<li>因为python没有const, 所以你自己要清楚哪些是变量是const不能改变的, 尤其是在循环的时候修改特别容易出问题!</li>
<li>变量更新的时机很关键.</li>
</ul>
</li>
<li><p>(2019年9月20日01:49:25) Jetbrains技巧总结</p>
<ul>
<li>复制行, 剪切行: ctrl+c/x, 注意光标移动到该行</li>
<li>删除行: shift+delete, 注意光标</li>
<li>复制到下一行: ctrl+d</li>
</ul>
</li>
<li><p>(2019年9月22日23:01:58) 阅读的意义:</p>
<ul>
<li>“任何人都可以通过广泛的阅读和反思，使个人的思维广度拓宽，解读角度多样化，措辞用语高级化，保有更持久坚固的汲取信息和加工信息的能力，获得理性思辨和自我检讨的能力。” 来自<a href="https://www.zhihu.com/question/305792030">这里</a></li>
</ul>
</li>
<li><p>(2019年9月28日00:26:07) 回头顾一下课业, 这几天主要做的事情有:</p>
<ul>
<li>买实体书看, 实体书还是要买的, 毕竟每页5分钱也是很便宜了, 并且能读的时间大大加长.</li>
<li>开始学习linux命令, 其实我觉得C和C++学得精了, Linux就是一个弟弟</li>
<li>Haskell继续探索.</li>
</ul>
</li>
<li><p>(2019年9月28日00:28:01) Linux记录一下</p>
<ul>
<li><a href="https://blog.csdn.net/u013122625/article/details/52967831">virualBox调节屏幕分辨率-注意addmode Virtual-1改成Virtual1</a></li>
<li><a href="https://stackoverflow.com/questions/16787916/difference-between-two-directories-in-linux/29299485#29299485">Linux比对两个文件夹下文件有哪些不同</a></li>
<li><a href="https://stackoverflow.com/questions/14922562/how-do-i-copy-folder-with-files-to-another-folder-in-unix-linux#14922600">Linux拷贝整个文件夹-包括所有文件</a></li>
<li>注意拷贝文件夹是把文件夹当成一个大文件来看的, 所以最后只是文件名, 而不是文件名+正斜杠, 注意!</li>
</ul>
</li>
<li><p>(2019年9月28日00:31:40) 手脚冰凉, 我的命数里一定有着”一叶知秋”的说法, 要注重运动呀!</p>
</li>
<li><p>(2019年9月28日00:41:04) 最近有个想法是将TA和教授的信息分门别类导入”邮箱”中的”人脉”里面.</p>
<ul>
<li>注意, 一定要确保能够用”课程号+TA”或”课程号+Pro”的形式搜到, 因为我不能记住很多人名</li>
<li>一定要做好归类的工作, 如果不能进行搜索的话.</li>
</ul>
</li>
<li><p>(2019年9月28日00:43:34) 知道搜索什么是很关键的, 很多时候为什么我们没法很快地迭代我们现有的知识, 就是因为一些关键的知识没有扎根在脑子里</p>
<ul>
<li>比如我现在去搜索copy directory, 我一定会跟上 recursion这种词, 因为我知道他是recursion的, 但是不知道这个的人可能就又要试个半天.</li>
<li>比如我现在想要看每步原子操作究竟改变了什么, 肯定就会想到步步backup然后依次diff的思路, 我不需要懂很多linux细节的知识, 但我知道这种基本的想法和思路, 所以我搜索起来就会非常快!</li>
</ul>
</li>
<li><p>(2019年9月28日01:12:17) windows下的分屏在处理虚拟机和实体机的问题上非常方便!</p>
<ul>
<li>win+(←): 成为左边的一栏</li>
<li>win+(→): 成为右边的一栏</li>
</ul>
</li>
<li><p>(2019年9月28日01:15:35) 搜狗拼音输入法, 百度手机输入法, 如何打出希腊字母呢? 去查查看吧!</p>
</li>
<li><p>(2019年9月28日03:04:09) 保持纯净的能力是很有必要的, 这点不仅仅在心灵上, 习惯上也是要这样子的, 举一些例子</p>
<ul>
<li>如果特别想学习, 那么就使劲学, 中途不要穿插任何与学习无关的项目<ul>
<li>这里的学习指的是对某一方面的拓展, 比如unix高级编程, 在看的时候就一点都不要考虑Haskell的事情, 因为这个对大脑也是一种分心.</li>
</ul>
</li>
<li>“玩耍”和”休息”是完完全全的两个概念, 这点我发现大家很容易搞混, 特别说明下:<ul>
<li>玩耍和学习是类似的, 都是一种消耗精力的活动, 就是玩久了也会没力气, 但是玩耍可以提高智商, 所以每天都应该专门玩耍一会儿</li>
<li>休息和玩耍学习这件事完全是两件事, 我个人认为休息=睡觉, 不管是趴在桌子上睡还是躺在床上睡都可以, 但是必须要休息, 不休息一没法玩二没法学习</li>
<li>休息的时候不要想玩得事情, 玩的时候不要想休息, 因为玩是一件应该做的事, 很多人觉得玩就等同于休息, 那我就请问你们大脑会不会因为多线程运行而爆炸?</li>
</ul>
</li>
<li>想要吃素就一点吃肉的想法也不要有, 不想吃素就吃一点肉也可以</li>
<li>游戏不好玩就别玩, 帝国时代也是一样的, 因为是和电脑对战因此中断什么的不可能产生多余的怨尤, 因此一旦觉得不开心了不想打了, 我就会立马停下来<ul>
<li>注意不是马上学习, 打完游戏之后大脑也是很累的, 也需要好好休息一会儿</li>
<li>趴桌睡觉的速率是很重要的训练环节, 不一定要睡着, 就是一定要出于什么都不想的状态.</li>
</ul>
</li>
<li>学习学累了请趴桌睡觉, 不要想着穿插其他的娱乐内容或学习内容, 这样很假, 要知道自己的精力不是很够, 与同年龄段的人相比更是要差上不少, </li>
<li>尽量使得大脑的线程是”中断续行”而不是”切换上下文”的状态, 其实道理都是很简单的</li>
<li>想看什么书就看什么书, 但是一次不能超过2本, 因为这样很假.<ul>
<li>编程书我的原则是, 一定要整理出博客来, 一定要做至少5组的网络搜索(疑问也好, 探索性的好奇心也好, 都可以), 能试着写一点代码的就写一点, 写不了代码的就补一点注释.</li>
<li>笔记做得花花绿绿的书, 整理完笔记之后一概不看!<ul>
<li>你可以买一本新的, 但是不要在旧笔记上加新笔记, 因为这个应该早就体现在你的博客里了, 不要让自己出于任何的混杂之中.</li>
<li>不要把一本书翻得破破烂烂的, 这样很假, 因为喜新厌旧是人们内心的通病, 没有必要与自己的人性较量, 该买新的就买新的, 也不贵.</li>
</ul>
</li>
</ul>
</li>
<li>想写什么程序就写什么程序, 但是注意:<ul>
<li>程序一定要从github上面clone &amp; push, 一来防止以外, 二来可以追踪自己哪天懈怠了</li>
<li>懈怠的意思不是中断, 也不是分心, 而是(在成为高手之前就)失去了探索的兴趣或者勇气耐心,<ul>
<li>博客不用天天更新, 但是一定有想法就一定要更新.</li>
<li>想做什么事情一定要马上去做, 不要延迟自己的满足感, 因为违背人性的事情做的再多, 虽然自己可能有一种自豪感, 但其实作为一种太过高邈的榜样, 反而是给追随者带来了很多压力的.</li>
</ul>
</li>
</ul>
</li>
<li>想做什么事情就赶快去做, 想睡一整天, 想躺床上看手机, 想打游戏打到凌晨, 赶紧去睡!去玩!去打游戏!因为你自己既然会想到这个, 说明你肯定对这个有些执念, 那么就赶紧去实现, 不要浪费时间!</li>
<li>如果你感觉到今天游戏没打好, 觉没睡好, 那么说明今天你的感觉不太对, 明明没那么想打游戏, 明明没那么想躺床上玩手机, 但是自己因为无聊然后不知道做什么比较好, 然后误以为自己很需要这两者, 这个时候你就要意识到, 其实自己很多时候是很想学习的, 尤其是无聊的时候, 只是因为自己羞于启齿, 觉得想学习这件事太TM虚伪了怎么的<ul>
<li>但事实就是这样的, 人总会有想学习的时候, 只是这种状态需要人们细心识别才能得出, 这就是关键, 如何识别而出自己想读哪一科, 这一点我也没掌握, 我现在只能意识到哇我好想读书, 那么我就顺从自己的心意读下去, 累了就休息, 一点都不想着玩耍.</li>
</ul>
</li>
<li>中途休息是很有必要的, 但是首先你要明确自己到底想干什么, 这点很多时候我就没有注意到, 导致我自己”回血”通常非常慢, 这点我也要努力克服, 也就是读大概45min-1h必须要休息一段时间, 这是强制性的, 因为大脑必须要定期清空一下缓存, 这是一个比较优秀的scheduling, 我要好好体会一下<ul>
<li>当然, 不管是学习也好, 玩耍也好, 都要强制规定自己45min-1h休息一次, 我自己这点就没有意识到, 以后我就要好好注意, 因为我两件事都发现不怎么好停下来, 但这还是很值得训练一下的, 毕竟是绝技之一嘛~</li>
</ul>
</li>
</ul>
</li>
<li><p>(2019年10月4日03:48:59) 注意一下, github查询历史似乎不能精确到秒, 因此我们要是想要更精确的话, 就直接在git commit的时候输入以下日期就好</p>
</li>
<li><p>(2019年10月4日03:50:18) 我的lambda演算功底实在可笑, 还是要踏实一点呀!</p>
</li>
<li><p>(2019年10月4日03:51:19) 为什么我帝国时代打缅甸胜率这么低? 难以置信, 统计一下我缅甸的胜率只有13%, 有点搞笑</p>
</li>
<li><p>(2019年10月4日22:54:47) 看TTPL, 看了半小时就昏昏欲睡, 看来这种计算机理论的东西我还是要多看网课比较好, 然后课下再慢慢进行看书补全.</p>
</li>
<li><p>(2019年10月7日04:43:13) 配好了”个人日记”, 耗时还是很长, 唉~</p>
</li>
<li><p>(2019年10月7日04:43:41) 因为用hexo写博客, 很容易md文件被发现而导致密码泄露, 今天终于找到一个可以使用默认密码的插件了, 详情请看此处: <a href="https://blog.bill.moe/encrypt/">hexo加密插件-可使用默认密码</a></p>
</li>
<li><p>(2019年10月7日04:44:58) 发现了一个又可爱又强大的男孩子, 嗯~</p>
<ul>
<li><a href="https://blog.bill.moe/">Bill Yang’s Blog</a></li>
</ul>
</li>
<li><p>(2019年10月7日05:06:31) 永久激活win10办法: 看<a href="https://www.jianshu.com/p/5853a18667d6">这里</a></p>
</li>
<li><p>(2019年10月7日05:07:08) 查看激活时长: 命令<code>slmgr.vbs -xpr</code></p>
</li>
<li><p>(2019年10月8日03:38:21) <a href="https://co5.me/2018/180613-wordcount.html">字数统计插件-安装教程</a></p>
</li>
<li><p>(2019年10月8日23:31:40) 发现密码出现在html里面了, 查了一下才发现是在header.swig, 感谢好友的提醒了, 这个保密工作还是要好好处理的!</p>
</li>
<li><p>(2019年10月9日09:50:01) 从今天开始, 多多注意身体情况!</p>
</li>
<li><p>(2019年10月9日09:50:21) hexo的md是很严格的, 很多时候就是多一个空格少一个空格的问题(我在—后面多打了一个空格就出问题了), 多注意吧…</p>
</li>
<li><p>(2019年10月10日07:31:17) 其实hexo直接ohnd “2019年10月10日07:31:35”(搜狗输入法打时间) 就可以了, 反正今天和昨天的记录也相差不多, 这样子只要注意一点, 就是title后面必须要用引号括起来(无误会呈现橙色, 橙色就代表成功.)</p>
</li>
<li><p>(2019年10月11日01:10:13) 重新搞了一下linux共享文件夹, 记录一下:</p>
<ul>
<li>自动挂载+固定分配都要有</li>
<li>rc.local里面填写这个:<ul>
<li>sudo mount –t vboxsf –o rw, uid=1000,gid=1000 UbuntuWinShare /home/seed/host</li>
<li>不要填mount -t vboxsf UbuntuWinShare /home/seed/host</li>
</ul>
</li>
<li>安装增强功能! 不然无法生效!</li>
<li>最后发现没有挂载到host下面, 但是还是有共享文件夹的, 在/media/sf_WinUbuntuShare下面, 这样也可以</li>
</ul>
</li>
<li><p>(2019年10月11日01:24:53) 林煜堃教了我怎么使用xshell, 看起来项目经验多的大佬就是厉害啊</p>
<ul>
<li>xshell下载</li>
<li>VBox-设置-网络-网络地址转换NAT-高级-端口转发-配置如下图</li>
<li><img src="/22400/NAT%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.jpg" class="" title="NAT端口转发-配置"></li>
<li>xshell设置如下:</li>
<li><img src="/22400/xshell%E6%96%B0%E5%BB%BA%E8%BF%9E%E6%8E%A5%E8%AE%BE%E7%BD%AE.jpg" class="" title="xshell新建连接设置"></li>
<li>然后选择无界面启动即可</li>
</ul>
</li>
<li><p>(2019年10月11日01:38:37) linux下设置路径别名(直接在terminal输入): <code>alias sf=&#39;cd /media/sf_UbuntuWinShare&#39;</code></p>
</li>
<li><p>(2019年10月11日01:41:57) win10自定义右键”发送到”按钮:</p>
<ul>
<li>资源管理期地址栏: <code>shell:sendto</code></li>
<li>复制快捷方式到该文件夹下</li>
</ul>
</li>
<li><p>(2019年10月11日01:31:42) <a href="https://www.zhihu.com/question/23551546">使用clion进行ssh连接-调试Linux中C程序</a></p>
</li>
<li><p>(2019年10月11日05:39:32) <a href="https://perry96.com/archives/882898e3.html">hexo报错SpawnFailed如何处理</a></p>
<ul>
<li>原因: 本地git仓库和github上面不同步, 也就是本地还没完成处理时github已经上传完成了, 这个时间差导致了错误.</li>
<li>解决办法: 回滚, gb -&gt; <code>git reset --hard &lt;commitId&gt;</code>(自己到github commits里面查找commentId)</li>
</ul>
</li>
<li><p>(2019年10月11日08:26:51) 今天hexo再次报错spawn Failed, 试了一下git reset发现不行, 我灵机一动使用vpn插件,成功! 感觉有点莫名其妙的!</p>
</li>
<li><p>(2019年10月15日15:02:16) 有时候搁置一下任务可能可以获得好的结果, 比如昨天卸载qt, 安装mingw-w64并配置到clion toolchains里面时就出现一个cmake配置不上去的尴尬情况, 但是今天一来就发现原来cmake是已经built-in在clion内部的, 只需要let clion detect就完全可以了</p>
<ul>
<li>当然这只是偶然情况而已, 实际上绝大多数的错误都是有既定原因+可以复现的, 单纯靠搁置+不理睬达成的只是偶然现象而已</li>
<li>既要有解决问题的决心与勇气, 又要用放弃问题, 暂时搁置问题的豁达感, 这是很重要的事</li>
</ul>
</li>
<li><p>(2019年10月15日15:06:04) 今天去吃一次麦当劳, 途中发现的一些生活小细节可以记录一下(可以merge到日记中)</p>
<ol>
<li>因为看到了路上有两个随地乱丢的纸杯, 上面写着永和豆浆, 我的直觉是怎么会有这么没公德心的人, 但是转念一想我们学校内部没有永和豆浆, 于是肯定, 纸杯源于可以送达到学校的外卖, 我使用饿了么一搜, 果然查找到了永和豆浆的外卖店, 这就是一点灵性.</li>
<li>路上随便看了下微信, 有一个”‘小陈小陈想啥啥成’撤回了一条信息”的消息, 我依稀记得昨天有个”小王小王当刑而王”(我当时只是查了下”当刑而王”的含义, 也就是”先经受磨难而后飞黄腾达”的含义), 于是我敏锐察觉到它们是同一种句式, 因此想到这两人应该是有共同的默契, 并且很有可能是情侣, 大概是一种心有灵犀的体现, 但后来我觉得可能只是一种新的流行语句, 因为很押韵并且很符合人们这种无端而把肉麻当有趣的廉价幽默感, 于是我百度一下(小王小王), 于是发现的确是一种流行的句式, 这也是一点灵性.</li>
<li>进入麦当劳后, 稀里糊涂的在点餐机上点了两遍产品定制的按钮, 所以产品定制必须重新选择, 一开始我还有点懊恼怎么会糊涂到这个地步, 后来我才想到这几点:<ul>
<li>首先, 这个产品定制必须”在确认前”可以随时更改, 因为可能顾客一开始想要一点冰可乐, 但后来想了想还是选择去冰的定制, 此时让顾客重新点餐显然不合适, 所以这个产品定制必须在确认前可以随时更改.</li>
<li>但是, 如果我忘记我是否进行过产品定制这一操作, 这该如何是好呢? 就像我一样稀里糊涂的点了两边产品定制的人, 肯定不少, 那么如何判断我是否已经选择了一项定制, 并且展示定制的内容呢?</li>
<li>显然, 他只要让我们能够看到当前定制的内容即可, 而是否更改当前的定制则不必关心, 所以他用小字部分显示了定制的内容, 如图所示:</li>
<li><img src="/22400/%E7%82%B9%E9%A4%90%E6%9C%BA-%E4%BA%A7%E5%93%81%E5%AE%9A%E5%88%B6-%E5%B0%8F%E5%AD%97%E9%83%A8%E5%88%86.jpg" class="" title="注意可乐" alt="不要冰"></li>
</ul>
</li>
<li>麦当劳微信二维码付款时红外线扫描没有反应, 一般的处理方式是用手去摸一摸扫描镜头, 这样绿光会变成红光, 此时扫描即可顺利完成(听见滴的一声), 这中间的原理是什么呢?</li>
<li>前两天发现墙上的钟不再走动了, 此时我将钟取下来查看, 此时我的做法是:<ul>
<li>我们起初无法判断是钟表电池耗尽还是其他故障导致钟不再走动了, 于是我们先必须判断有了电池时钟是否走动, 如果我贸然直接去小卖部买电池, 要是买回来装好后发现钟摆依然不走, 此时的我就是出钱出力不讨好了, 于是我先想着测试一下.</li>
<li>考虑到蓝牙鼠标内也有电池, 所以我先将鼠标电池拆下, 然后换到钟表的内部, 发现其正常走动, 用手机计时器完成一分钟计时, 误差在1-2s之内, 属于量产的便宜钟表的正常范畴, 于是我明白, 只需要换上电池即可.</li>
<li>于是去中行物业要一节电池, 走在路上我想</li>
</ul>
<ol>
<li>学校很多房间有很多钟表, 每个钟表都有可能因为各种原因没电, 那么换电池就变成一种非常普遍的操作.</li>
<li>钟表不走已经好多天了, 其间没有人在意这件事, 说明学生们对这一点并不热心, 所以我不能指望他们. 学生们潜在的一个”不能自己服务他人, 否则潜在的掉价”的这种心理也是可见一斑了, 这就是我”伪物”的哲学的反面.</li>
<li>能不能在各个部分之间建立电池的buffer, 就是逸夫书院固定放几个电池, 其他书院也各自放几个电池, 这样一旦有时钟没电, 就能得到及时的就近处理, 而不是物理上跑一趟中航物业的远路, 因为我这次跑一趟的潜在条件是我身处下园, 要是在上园的同学, 会不会就因为路途的遥远而放弃了呢? </li>
<li>这件事只有我一个人有意识是绝不行的, 因为我迟早会毕业, 然而学校将会一直存在, 并且就算不是我们学校, 任何一间中小学都存在这样的情况, 因此我觉得这件事应该要广为流传, 就是建立电池buffer的事情, 这种小的细节就是想不到+流传不广, 所以人们才需要跑很远的路来完成来实现. </li>
<li>于是我发了邮件给各个书院的老师,请他们帮忙主持一下, 当然我的名字需要保密一下, 因为我不想成为榜样, 很多事情就是因为有了榜样所以人们才故意不想照着做的, 因为好像自己在做这件事的时候就是为了这个单独的个体去做的, 这样好事情就没法推广开, 并且我自己也根本不想跟雷峰一样把姓名和好事绑定起来, 跟屁虫什么的实在讨厌极了.</li>
</ol>
</li>
</ol>
</li>
<li><p>(2019年10月15日15:48:50) 前天熬夜重写了3100报告, 感觉自己写得很爽! 这篇报告真正显示了我自己的才华与研究成果, 这也证明了学习Haskell并不是玩物丧志, 而是有战略眼光的选择! </p>
</li>
<li><p>(2019年10月15日16:03:44) 作业一定要有留出至少5天的剩余时间, 否则计划赶不上变化的!</p>
</li>
<li><p>(2019年10月15日16:33:43) 简要概括一下这几天到底有哪些值得记住的事情:</p>
</li>
</ul>
<ol>
<li>和一个女生在机房深夜聊天(据说学的是心理学), 主要是聊哲学聊动漫, 感觉她十分崇拜我, 此后我和她一路聊到上园则返, 我的直觉一开始时感到有些受用并且感激的, 然而之后却感受到一种厌恶感, 因为我突然发现她来机房吃零食, 并且吃得到处都是这样的事情, 这是我无数次感觉自己的学识与经验被明珠暗投的其中一个小例子, 这也使我对女性普遍的厌恶感又增长了几分.</li>
<li>厌恶之余我开始回想, 我在本校熟食的女生屈指可数, 基本都处在半生不熟的状态, 其中我觉得很优秀的个体有几个学姐, 几个同学, 而与我熟识的则只有谭宣一人, 我可以感受到她的强大与理智, 这是很难得的情况, 她本身也力图使我进入日不落开发工作室, 然而我实际上并没有这方面的打算, 我之所以感觉到有点无奈, 是因为感觉欠她的人情有点积累得过多了, 然而我却没有太多好的途径去帮助她, 并且我们二人应该都是没有对彼此超出友情以上的任何想法的</li>
<li>看&lt;海马&gt;连看了我已经记不清楚是几遍了, 非常喜欢里面的Kichi, 为此我还在B站上写了两篇专栏, 可惜没有人回复我(这也很真实), 我感觉现在我做什么事情都可以或者都愿意以一种研究的心态去处理去完善它, 这就是一个好的预兆, 说明说我自己是越来越成熟与理性了, 并且我还没有丢失掉浪漫的能力与善良的本性.</li>
</ol>
<ul>
<li><p>(2019年10月19日17:10:13) 科学小飞侠好看! 原来胸大的理由可以是”承载了整个世界的恶意”呀hh</p>
</li>
<li><p>(2019年10月19日17:10:42) 必须养成”现场检查”+”观察反馈”的习惯与意识, 这种说法有点抽象, 就是说我们做一个动作是一定要产生特定效果的, 但是这个效果很有可能因为过程中的一些问题然后出错, 这个时候就需要马上进行现场检查, 根据当下反馈来判断成功与否, 具体例子如下:</p>
</li>
</ul>
<ol>
<li>手机充电的时候, 请你一定要等到”屏幕亮起来”+”出现充电显示画面”才离开, 否则情况很可能是因为插头没有插好, 所以充电根本没有进行!</li>
<li>电脑充电也是一样的, 观察到电脑出现充电的显示画面才离开</li>
</ol>
<ul>
<li>(2019年10月19日17:15:01) 必须养成时刻检查自己在做什么的习惯, 许多时候我看书还是容易跳来跳出, 或者上网找一些学习资料什么的, 这样就很容易演变为刷知乎这种行为, 其实我们对自己需要寻找的答案内心其实很清楚的, 只是因为没有及时加载到显意识这边来, 所以要做到:</li>
</ul>
<ol>
<li>每一次浏览, 都要清楚自己到底要获取什么消息, 什么知识</li>
<li>并不是禁止”随便翻翻网页”这样的行为, 但是这样的行为应该和平时的上网区分开来, 变成”日常娱乐”的一小部分.</li>
<li>如果发现了好的番剧, B站上找不到, 请你马上记录一下, 然后用百度云下载下来到本地进行观看,  不要在看与不看之间停留</li>
</ol>
<ul>
<li>(2019年10月19日17:21:14) 再次重申, 要放松要娱乐就马上去执行就好了, 要发呆也尽管去发呆就好, 就是不要把时间浪费在到底是干正事好还是发呆/休息/娱乐上面这种”中间复杂的思路”上面就好, 如果不喜欢学习时旁边有人, 那么就尽管换个教室出去学习便是了, 决定做一件事是不能过于纠结的, 虽然纠结也是人生很重要的一部分, 但是也应该专门把纠结当成一件独立的事情, “阿拉阿拉我现在要开始纠结了哦”这样子去考虑才对</li>
</ul>
]]></content>
      <tags>
        <tag>碎片信息集散</tag>
        <tag>长期更新</tag>
      </tags>
  </entry>
</search>
